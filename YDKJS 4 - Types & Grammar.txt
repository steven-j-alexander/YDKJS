===========================================Chapter 1===========================================
Types

A rough definition of a type in JavaScript is: "an intrinsic, built-in set of characteristics that uniquely identifies the behavior of a particular value and distinguishes it from other values, both to the engine and to the developer."

-Built-in Types-
The seven built-in JS types are: null, undefined, boolean, number, string, object, symbol (new in ES6). All of these are considered primitives, except for `object`.
The `typeof` operator inspects a given value and returns the type. `null` is buggy and returns a value of `"object"`. It should return `"null"` but the bug has existed for so long that changing it would cause a lot of harm to legacy code, so it is left as is.
To test a `null` value using its type, you need to create a compound condition that, in addition, checks the value's falsiness, as `null` is the only "falsy" primitive value that returns a `typeof` of "object".
Functions, although considered a subtype of `object`, are also identified by `typeof`. Functions are considred "callable objects" in JS, as they have an internal [[[Call]]] property, allowing them to be invoked.
Because functions are objects, they can have properties, which include the parameters they were declared with. This is useful if you want to run an object utility such as `.length` on a function.
Arrays are also considered a subtype of `object`, with the included ability to be numerically indexed.

-Values as Types-
Values have types in JS, rather than variables. Variables can hold any value, therefore they can hold any type.
The type of value a variable can hold is mutable. You can think of this as JS not having "type enforcement".
A value's type cannot be changed. Coercion is the act of creating a new value from a value of a different type. `typeof` is simply checking the type of the value contained in a variable.

-`undefined` vs "undeclared"-
A variable that has been declared, but currently has no other value associated with it, has a value of `undefined`.
An undeclared variable is a variable that has not been formally declared in the accessible scope.
Some browsers will return a warning that a variable has not been defined when in fact it hasn't even been declared. The `typeof` operator also has a safeguard that engages in a similar behavior, so be aware.

-`typeof` Undeclared-
The `typeof` safeguard is handy when checking for the existence of a variable or a function without throwing an error, especially in instances where multiple script files can load variables into shared global namespace.
Recall that `if` statements are only block-scoped, so if you are performing a `typeof` check where "undefined" results in an assignment operation, you want to be sure to avoid preceding your declaration with the `var` keyword, as this would hoist the declaration to the top of the enclosing scope, even if the `if` condition fails. When defining a polyfill for special types of built-in global variables, sometimes referred to as "host objects", or variables specific to particular browses, this could cause an error pertaining to duplicate declaration.
All global variables are also properties of the global object, which in a browser is essentially the `window` object, so you can also perform safe checks for global vars in `if` conditionals using `window.prop` syntax. No `ReferenceError` is thrown on trying to access object properties that don't exist. Some developers prefer to avoid this though, as accessing the `window` object directly can be unwise if your code needs to run in multiple JS environments (such as node.js).
`typeof` is useful for checking the existence of variables in places other than the global object as well, although some developers prefer using dependency injection. If you wanted to check and see if program or module contained a particular helper utility before adding it in, you can check for the `typeof` said variable. If the check fails, you can have a default anonymous function defined and ready to go.
The dependecy injection design pattern is similar, but instead of implicitly checking for the feature/variable directly around it, you would need to have the dependency explicitly passed into the function that performs the check (which now simply checks if anything was passed to it).

===========================================Chapter 2===========================================
Values

-Arrays-
Like type-enforced languages, JS `array`s are simply containers that allow storage of any type of value. Pre-sizing is not necessary.
Using the `delete` operator on an array will remove a slot from it, but does not update its `length` property. Also, creating "sparse" arrays (leaving empty/missing slots) will still leave a `length` equal to the highest index, plus 1 (for the "0" index). Slots you haven't defined will have the same behaviors as a slot that has been explicitly defined as `undefined` would.
`string` keys/properties added to an array object do not have an impact on its `length`, UNLESS the `string` value can be coerced into a base-10 numerical value, in which case the value will be treated as the numerical index. Because of this (and the fact that general objects exist), it's best to use objects for storing key/value pairs.

-Array-Likes-
There are instances where you will need to take "array-like" collections of values and coerce them into actual arrays to be operated upon using the array object utilties. Many DOM query operations return array-like collections, as well as the ES6-deprecated function `arguments` object. One easy way to do this with `arguments` is to make a function that assigns a call of `Array.prototype.slice.call( arguments );` to a variable, and then call that function while passing your list of arguments.
In ES6, you can instead use `Array.from(..)` to perform the same task of taking anything passed to it and coercing it into a new array.
`.push` allows you to add more values to an array.

-Strings-
JS strings are not really the same as arrays of characters. JS strings are immutable, whereas arrays are not.
Older versions of IE did not allow for index-style character access on strings. The correct approach is considered to be `string.charAt(..)`.
Because strings are immutable, all string methods that alter contents are actually returning a new `string` each time, while many of `array`s manipulation methods do modify content.
Due to these differences in mutability, any `array` methods that directly alter existing values cannot be used on `string`s, but anything non-mutable that returns a new value can be "borrowed".
A quick hack to reverse a simple string to convert it to an array, use the `reverse()` utility, and then convert back to a string: `string.split( "" ).reverse().join( "" );`. You'd need more complex utilities to perform the same operation with strings containing complex unicode characters.
If you are performing a lot of operations on a set of strings that require you to treat them like arrays of characters, you should probably just make them arrays of characters, simply `join("")`ing them whenever you need to represent them as strings.

