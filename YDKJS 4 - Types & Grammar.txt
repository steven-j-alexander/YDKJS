===========================================Chapter 1===========================================
Types

A rough definition of a type in JavaScript is: "an intrinsic, built-in set of characteristics that uniquely identifies the behavior of a particular value and distinguishes it from other values, both to the engine and to the developer."

-Built-in Types-
The seven built-in JS types are: null, undefined, boolean, number, string, object, symbol (new in ES6). All of these are considered primitives, except for `object`.
The `typeof` operator inspects a given value and returns the type. `null` is buggy and returns a value of `"object"`. It should return `"null"` but the bug has existed for so long that changing it would cause a lot of harm to legacy code, so it is left as is.
To test a `null` value using its type, you need to create a compound condition that, in addition, checks the value's falsiness, as `null` is the only "falsy" primitive value that returns a `typeof` of "object".
Functions, although considered a subtype of `object`, are also identified by `typeof`. Functions are considred "callable objects" in JS, as they have an internal [[[Call]]] property, allowing them to be invoked.
Because functions are objects, they can have properties, which include the parameters they were declared with. This is useful if you want to run an object utility such as `.length` on a function.
Arrays are also considered a subtype of `object`, with the included ability to be numerically indexed.

-Values as Types-
Values have types in JS, rather than variables. Variables can hold any value, therefore they can hold any type.
The type of value a variable can hold is mutable. You can think of this as JS not having "type enforcement".
A value's type cannot be changed. Coercion is the act of creating a new value from a value of a different type. `typeof` is simply checking the type of the value contained in a variable.

-`undefined` vs "undeclared"-
A variable that has been declared, but currently has no other value associated with it, has a value of `undefined`.
An undeclared variable is a variable that has not been formally declared in the accessible scope.
Some browsers will return a warning that a variable has not been defined when in fact it hasn't even been declared. The `typeof` operator also has a safeguard that engages in a similar behavior, so be aware.

-`typeof` Undeclared-
The `typeof` safeguard is handy when checking for the existence of a variable or a function without throwing an error, especially in instances where multiple script files can load variables into shared global namespace.
Recall that `if` statements are only block-scoped, so if you are performing a `typeof` check where "undefined" results in an assignment operation, you want to be sure to avoid preceding your declaration with the `var` keyword, as this would hoist the declaration to the top of the enclosing scope, even if the `if` condition fails. When defining a polyfill for special types of built-in global variables, sometimes referred to as "host objects", or variables specific to particular browses, this could cause an error pertaining to duplicate declaration.
All global variables are also properties of the global object, which in a browser is essentially the `window` object, so you can also perform safe checks for global vars in `if` conditionals using `window.prop` syntax. No `ReferenceError` is thrown on trying to access object properties that don't exist. Some developers prefer to avoid this though, as accessing the `window` object directly can be unwise if your code needs to run in multiple JS environments (such as node.js).
`typeof` is useful for checking the existence of variables in places other than the global object as well, although some developers prefer using dependency injection. If you wanted to check and see if program or module contained a particular helper utility before adding it in, you can check for the `typeof` said variable. If the check fails, you can have a default anonymous function defined and ready to go.
The dependecy injection design pattern is similar, but instead of implicitly checking for the feature/variable directly around it, you would need to have the dependency explicitly passed into the function that performs the check (which now simply checks if anything was passed to it).

===========================================Chapter 2===========================================
Values

-Arrays-
Like type-enforced languages, JS `array`s are simply containers that allow storage of any type of value. Pre-sizing is not necessary.
Using the `delete` operator on an array will remove a slot from it, but does not update its `length` property. Also, creating "sparse" arrays (leaving empty/missing slots) will still leave a `length` equal to the highest index, plus 1 (for the "0" index). Slots you haven't defined will have the same behaviors as a slot that has been explicitly defined as `undefined` would.
`string` keys/properties added to an array object do not have an impact on its `length`, UNLESS the `string` value can be coerced into a base-10 numerical value, in which case the value will be treated as the numerical index. Because of this (and the fact that general objects exist), it's best to use objects for storing key/value pairs.

-Array-Likes-
There are instances where you will need to take "array-like" collections of values and coerce them into actual arrays to be operated upon using the array object utilties. Many DOM query operations return array-like collections, as well as the ES6-deprecated function `arguments` object. One easy way to do this with `arguments` is to make a function that assigns a call of `Array.prototype.slice.call( arguments );` to a variable, and then call that function while passing your list of arguments.
In ES6, you can instead use `Array.from(..)` to perform the same task of taking anything passed to it and coercing it into a new array.
`.push` allows you to add more values to an array.

-Strings-
JS strings are not really the same as arrays of characters. JS strings are immutable, whereas arrays are not.
Older versions of IE did not allow for index-style character access on strings. The correct approach is considered to be `string.charAt(..)`.
Because strings are immutable, all string methods that alter contents are actually returning a new `string` each time, while many of `array`s manipulation methods do modify content.
Due to these differences in mutability, any `array` methods that directly alter existing values cannot be used on `string`s, but anything non-mutable that returns a new value can be "borrowed".
A quick hack to reverse a simple string to convert it to an array, use the `reverse()` utility, and then convert back to a string: `string.split( "" ).reverse().join( "" );`. You'd need more complex utilities to perform the same operation with strings containing complex unicode characters.
If you are performing a lot of operations on a set of strings that require you to treat them like arrays of characters, you should probably just make them arrays of characters, simply `join("")`ing them whenever you need to represent them as strings.

-Numbers-
`number` is the only numeric type currently availed in JS. It encompasses both integers and fractional values. JS uses double-precision format floating-point.
You can read about IEEE 754 to understand how these numbers are stored in memory.

-Numeric Syntax-
The leading and trailing portions of a decimal value are optional (".42" or "42.").
Very large and small numbers will be outputted in exponential form by default, providing the same output as the `toExponential()` method.
`number` values, having the ability to be boxed into the `Number` object wrapper, are availed access to utility methods built into `Number.prototype`.
`.toFixed(..)` allows you to specify how many decimal places you want a value to be displayed with as a `string` representation.
`.toPrecision(..)` works similarly, but allows you to specify how many significant digits can be used to refer to a value, meaning you can set it to a smaller number of digits than the real value, causing them to round up or down.
You can use these `Number` methods direct against numerical values, but recalling that a decimal point without a trailing value is acceptable syntax in JS, you have to be certain the value contains a decimal point (in addition to the dot operator that notates a separation between the value and the property call), or that you wrap the value in a parenthesis, in order to avoid a `SyntaxError`. It is uncommon to access property methods directly on primitive values, so this is not likely to be seen often. You can also validly exclude the decimal point and instead include a space between the value and the dot operator, but this is not recommended by the author.
You can define numerical values with decimals when using exponent form. ie. `1.7E4` is equal to `17,000`.
Express `number` literals in other bases than 10 by preceding a value with `0x` or `0X` for hexadecimal, a `0` for octal pre-ES6 or `0o`/`0O` in ES6+, and `0b`/`0B` for binary. Author advises to stick to the lower-case letter syntax for readability.

-Small Decimal Values-
With IEEE 754, binary floating-point is not perfectly precise, which can lead to comparisons of equations using fractional values failing equality comparisons to what should be their resulting values.
The most acceptable way to get around these sorts of situations is to use a small rounding error as the comparison's "tolerance". This value is often called the "machine epsilon", usually 2^-52 for JS `numbers`.
As of ES6, this tolerance value is now predefined with a constant-style identifer of `Number.EPSILON`. You can also polyfill it using `Math.pow(2, -52)`. You can create a function that, taking both values as arguments, checks to see if the absolute of the difference between these two values is less than the tolerance value of `EPSILON`.
The max value that can be represented is 1.798+e308, or `Number.MAX_VALUE`. The minimum representable value is `5e-324`, or `Number.MIN_VALUE`.

-Safe Integer Ranges-
The range of values that is considred "safe" for whole integer `number`s is smaller than the range one would infer by `Number.MAX_VALUE`. That value is `2^53 - 1`, or 9007199254740991, just over 9 quadrillion. It is defined in ES6 as `Number.MAX_SAFE_INTEGER`.
The minimum safe integer is also defined in ES6 as `Number.MIN_SAFE_INTEGER`, and is equal to -9007199254740991, which is just a subtraction of the max.
A common encounter caused by this limitation comes in dealing with 64-bit IDs from things such as databases, which exceed safe value bounds. Because of this, they must be stored as `string`s. If math operations are to be performed on such large values, a "big number" utility would be required.

-Testing for Integers-
ES6 includes a utility to check if a value is an integer: `Number.isInteger(..)`. It basically checks if the value is 1. a number and 2. has a modulus of zero when divided by one.
Another ES6 utility for checking if a value is a "safe integer": `Number.isSafeInteger(..)`, which performs the same check as `Number.isInteger(..)`, but also ensures the absolute value of the passed value is less than or equal to the value of `Number.MAX_SAFE_INTEGER`.

-32-bit (Signed) Integers-
Numeric operations such as bitwise are defined for 32-bit numbers, which are even smaller than the safe range. That range is between `Math.pow(-2,31)` and `Math.pow(2,31)-1`.
You can force a number into a 32-bit signed integer value by using the bitwise OR operator (`val | 0`). Since the bitwise operator can only handle 32-bit integer values, any excess bits will be thrown out. OR'ing the remaining value with zero is essentially a no-op (no operation).
Passing certain values such as `NaN` and `Infinity` will pass through an abstract operation called `ToInt32` and end up with a value of `+0` when passed to a bitwise operator, and are considered to not be 32-bit safe.

-Special Values: The Non-`value` Values-
`null` is an empty value or had a value that it doesn't hold anymore. The label and value are both `null`. 'null' is a special keyword, rather than an identifier. You can't assign anything to it like a variable.
`undefined` has not had a value yet or can be considered to be missing. The label and value are both `undefined`. `undefined` is also an identifier.

-Undefined-
Outside of strict-mode, you can actually assign a value to the global `undefined` identifier.
In either strict or non-strict mode, you can make a local variable named `undefined` and assign a value to it.
Don't do either of these.

-`void` Operator-
Another way to get the `undefined` value is via the `void` operator. It "voids" out any values returned by the expression on the right-hand of the operand, always resulting in a value of `undefined`. Note it does not modify the existing value, only returning `undefined` for that `void`ed expression.
To represent `void` as a standalone `undefined`, you would use the conventional `void 0`, although there is no practical difference between this and any other resulting voided value.
`void` could be used in a return statement that included a `setTimeout(..)` that ran if a condition failed, ensuring no value was returned that could have potentially resulted in a false positive, although you could just separate those two actions.
A need for `void` is rare.

-Special Numbers: The Not Number, Number-
Not using a `number` for either operand in a math operation will result in a value of `NaN`. Author states it better to consider `NaN` to be "invalid number", "failed number", "bad number", rather than "not a number", seeing as the `typeof` `NaN` still resolves to `number`. `NaN` can be considered a special error condition within the set of normal `number`s.
`NaN` is never equal to any other `NaN` value (including itself). It is the only value in JS that is not reflexive.
There is a global built-in utility called `isNaN(..)` that is intended for checking if a value is `NaN`, but it (buggily) just checks if a value is literally a valid number or not, so caution advised.
In ES6 there is a new and improved replacement utility called `Number.isNaN(..)` that *actually* checks if a value is `NaN` or not. One polyfill for this would simply perform the same global `isNaN(..)` check, but would also require that the value was still a `number` in order to pass. An even simpler polyfill would be to compare the value to itself, recalling that `NaN` is not a reflexive value, and will only pass if it fails this comparison.

-Infinites-
Math operations resulting in infinite numbers do not throw compiler errors like traditional compiled languages, as JS has an `Infinity` (or `Number.POSITIVE_INFINITY`/`Number.NEGATIVE_INFINITY`) value.
Negative infinity results from equations where one, but not both, of the operands are a negative value.
Due to the numeric limitations of IEEE 754 floating-point, you can get a return value of `Infinity` even with operations such as addition or subtraction.
IEEE 754's  "round-to-nearest" mode will cause a number just under max value, when added to a max value, to round back down to max value, rather than up to `Infinity`, as it computes that as being the closer value.
You cannot math a value from `Infinity` back into a finite value.
`Infinity / Infinity` equals `NaN`.
A positive finite `number` divided by `Infinity` equals 0.

-Zeros-
Negative zero (`-0`) results from multiplying or dividing a negative number by zero. It cannot result from addition or subtraction operations.
Some older browsers still report this value as a simple zero. The spec also requires that converting a negative zero to a string will result in a string form of positive zero (`0`). The same requirement does not apply when working in reverse. This also occurs when using the `JSON.stringify(..)` method, with `JSON.parse(..)` converting negative zero strings into the proper negative zero `number`.
This deception also applies to comparison operators. According to them, `-0 === 0`.
To check if a value or expression is equal to negative zero, you'd need to write a function that both checks if the value is zero, and then checks if a value of 1 divided by that zero is equal to `Number.NEGATIVE_INFINITY` (`-Infinity`).
It may seem useless to know this, but there are some applications where negative zeros are utilitized, such as in denoting the direction of movement in an animation frame. Preserving the sign can prevent the unwanted loss of information in such a circumstance.

-Special Equality-
In ES6, there is a new utility called `Object.is(..)` that can test two values for absolute equality, including the special values mentioned.
This performs an equality check while combining the `NaN` and `-0` checks of the previously mentioned ES6 utilities into one method.
Try and use `Object.is(..)` only where these special cases may be encountered, as using simple comparison operators are likely more efficient.

-Value vs. Reference-
In other languages, you can syntactically specify whether a value is assigned or passed by means of value-copy or reference-copy.
In C++, you can pass a variable into a function and have its value updated by declaring a function parameter (`int& myNum`). When you pass a variable into the function, `myNum` will now reference that variable, similarly to how a pointer works. Without a reference parameter, the value passed in will simply be copied, regardless of its complexity.
In JS, there are no pointers. There are references, but they are simply variables pointing at shared values. You cannot refer one JS variable to another, only to values.
The only thing that determines whether a value will be value or reference-copied in JS is the type of value being passed.
Simple values (scalar primitives) are always value-copied: `null`, `undefined`, `string`, `number`, `boolean`, and `symbol`.
Compound values (`object`s and any `object` subtypes) are reference-copied on assignment/passing. There is no hierarchy for variables that share these value references. They are equal peers.
Reassigning the value of a variable that was previously assigned a compound value reference will not change the reference or value of any of the other variables pointing at that initial compound value reference.
To pass a compound object by value-copying, you would need to manually copy it yourself. For arrays, you can pass them into a function using `a.slice()`.  `.slice()` creates a shallow copy of an array when no overload parameters are provided.
To pass a scalar primitive value as a reference-copy, you would need to wrap it in another compound value, such as an object or array.
Reference-copying a scalar primitive value boxed in its respective object wrapper (`Number` for `number`, etc.) and then passing that to a function in hopes of being able to modify the value referenced is a no-go. The values contained in these object wrappers are immutable, and any variable references them would have to create a new `Number` in order to reference any other value. Attempting to modify a `Number` reference "unboxes" the value from the `Number` object, resulting in the modified value being directly (and separately) referenced by the variable.
You can only add properties on top of a scalar primitive object wrapper such as `Number`.
You are better off just manually wrapping objects in order to reference-copy, as previously suggested.

===========================================Chapter 3===========================================
Natives

`String`, `Number`, and similar built-in type functions are called "natives".
These natives can be used as native constructors, similar to other languages like Java, but they actually create a wrapper object (natives are subtypes of `object`) that contains the primitive value.

-Internal [[Class]]-
Values that are a subtype of `object` contain an additional [[Class]] property (as in "Class"ification) that (usually) denotes the built-in native constructor for the given subtype. It can't be accessed directly, only indirectly through use of the `Object.prototype.toString(..)` method called against your value.
For primitive values `null` and `undefined`, `Null` and `Undefined` are returned, even though no native constructor exists for these values.
Other simple primitive values will be automatically boxed into their respective object wrappers, those of which will be revealed as the value's internal [[Class]].
These behaviors have changed somewhat from ES5 to ES6. Previous notes are likely pertaining to ES5.

-Boxing Wrappers-
Since primitive values don't have properties or methods, boxing them into their objects wrappers provides a means to access their type methods.
Because browsers have optimized access of these methods when performed on primitive values, trying to "pre-optimize" by manually wrapping said primitives in objects before running these methods against them actually results in slower performance.
That being said, just allow boxing of primitives to happen implicitly, rather than using their object forms directly.

-Object Wrapper Gotchas-
If for some reason you do explicitly wrap a value in it's object form, be aware that objects themselves are truthy, so a check of the truthiness of a variable referencing that object will actually be performed on the object itself, rather than the value it contains.
While still discouraged to manually box a primtive, and also while this doesn't seem to resolve the issue outlined above, it is suggested to manually wrap values using `Object(..)` rather than explicitly defining the wrapper type.

-Unboxing-
To get the underlying primitive value out of an object wrapper, use `.valueOf()`
Unboxing can occur implicitly via coercion when the object wrapper is used in a way that requires the use of its underlying primitive value.

-Natives as Constructors: `Array(..)`-
With `array`, `object`, `function`, and regexp, the literal and constructor form create the same unwrapped value, so stick with the literal form when possible.
`Array(..)` construction does not require `new` in front of it, and construct a new object the same regardless of the keyword's presence.
If only one numerical value is passed to `Array(..)`, that value will be used to "pre-size" the newly-constructed array. It's still an empty array, but will have a `.length` property whose value matches the value you passed. This is essentially a "sparse array", and is not a recommended array to construct. Chrome and Firefox's dev consoles currently display these `length`-defined slots as "empty", which is better than the "undefined" or ","+1 values they were previously mis-defining.
 
-Ugh.-
With empty arrays posessing a pre-defined `length` property value, you will not be able to iterate over using `.map`, as there is nothing there, but an array method like `.join` would still work, because the method loops through the array's defined `length` value in order to determine how many times it's supposed to append to the newly-created string.
The `.apply` method is a utility similar to `.call` that is availed to all functions. Instead of providing individual arguments, you pass it an array-like object that is then spread out into individual arguments before being passed to the function it was applied to. This "spreading out" behavior is performed by a `for` loop, similar to that of the `.join` method in that it loops one cycle for each unit of length in the calling object, iterating through and adding the provided argument each cycle. With `.apply`, the argument to be added is also iterated through until you run out.
`Array.apply( null, { length: .. } )` feeds the array a parameter of property `length` with a value of whatever you give it. The `.apply` loop will then run, creating an array index for each unit of length in the array. Because no other values are provided, there is nothing to add to each index as it's created, resulting in a value of `undefined` for each of them.
The key difference here is that `.apply` is physically creating each index as specified by the `length` property (but not defining a value in any of them), whereas `Array( val )` only assigns a value to the `length` property value.
Use `.apply` over `Array( val )` to avoid empty slots. Avoid intentionally creating empty-slot arrays.

-`Object(..)`, `Function(..)`, and `RegExp(..)`-
Like `Array(..)`, these constructors are optional and to be avoided unless necessary.
There's no practical reason to use the `new Object(..)` constructor form over object literals.
`Function(..)` can be useful in rare situations where you need to dynamically define its parameters and/or body. Don't use in place of `eval(..)`.
Literal forms of regular expressions are preferable for syntax and superior performance, due to JS precompilation and caching, although the constructor form can be very useful when dynamically defining a regexp pattern.

-`Date(..)` and `Error(..)`-
There is no literal form for either of these native constructors.
You can get the current timestamp by calling `.getTime()` on an instance of a date object, but an even easier way is to use ES5's `Date.now()`, which simply returns a new `Date` object with the `.getTime()` method already applied against it.
Calling `Date()` without instancing it with the `new` keyword will return a string representation of the current time, although the format itself is not represented in the language spec and liable to be inconsistent.
`Error(..)` behaves the same with or without `new` instancing. They are primarily useful for the fact that error objects capture detailed information on the execution stack and its current state, including the function call-stack and the line number where the error object was created.
Error objects are typically used with the `throw` operator, which halts execution of the application, instead skipping to the next `catch` block in the call-stack. Error objects usually have a `message` property, which are usually best-called by the `.toString(..)` method.
There are several other specific error-type natives that are rarely used manually, usually relegated to automatic execution during real exception error situations: `EvalError(..)`, `RangeError(..)`, `ReferenceError(..)`, `SyntaxError(..)`, `TypeError(..)`, and `URIError(..)`.

-`Symbol(..)`-
New to ES6, symbols are "unique" (not totally guaranteed) values that can be used as object properties without fear of collision. There are existing symbols for new built-in ES6 behaviors, and you can also define your own. You can't resolve the actual value of a symbol from your program.
The `Symbol(..)` native constructor is used to create new symbols, but will actually throw an error if you try to create one with the `new` keyword while doing this.
Symbols are primarily used for special or private properties, although `Object.getOwnPropertySymbols(..)` publicly reveals the symbols on an object. For some, they replace the use of underscore prefixing special property names.
Symbols are simple scalar primitives and not objects.

-Native Prototypes-
Built-in native constructors all have their own `.prototype` object, each containing behaviors specific to their object subtype, availed to both any constructor objects and primitive values via boxing.
All `.prototype` behaviors that modify an existing value are actually returning a new value with the modification enacted.
Some native prototypes aren't simple objects. `Function.prototype`, `Array.prototype`, and `RegExp.prototype` are all typed to their respective literal type, are (their form of) empty, and can even be modified.

-Prototypes As Defaults-
Pre-ES6, it's handy to use the `val = val || ...` trick with functions expected the last three mentioned `.prototype`s native objects as a means to ensure they are set to an empty form if they weren't passed in. This is especially useful when you realize that manually defining empty values of these native types would mean they would be recreated for every call to that function, meaning more resource hogging.
Be aware though, that you can still modify `Array.prototype` itself if you aren't careful. In fact, it's not always the best idea to rely on `.prototypes` for defaulting values.
In ES6, default values can be set for parameters using native syntax in the function declaration.

===========================================Chapter 4===========================================
Coercion

-Converting Values-
Converting values from one type to another is often called coercion when implicit, and type casting when explicit. It's often considered that type casting is done at compile-time in statically-typed languages, whereas implicit type coercion occurs during run-time in dynamically-typed languages.
Often in JS, both implicit and explicit type conversions are referred to as coercion, so you can use implicit/explicit coercion to differentiate the two.
Coercion in JS always results in scalar primitives, and never complex values.

-Abstract Value Operations: `ToString`-
ES5 spec outlines "abstract operations" (interal-only) that define the rules of value conversion, such as `ToString`, `ToNumber`, `ToBoolean`, and `ToPrimitve`.
Built-in primitive values that aren't strings have natural stringification.
Any object that has its own `toString()` method that is used in a `string`-like way will automatically call that built-in method.
Any normal object that uses the default `toString()` method will use the one present in `Object.prototype` to return a string containing both the type (object) and internal [[Class]] property value.
Array objects have an overridden default `toString()` method that stringifies the contents and concatenates them together with a `,`.

-JSON Stringification-
`JSON.stringify(..)` serializes a value into a JSON-compatible string, but does not do so in a way that would be considered direct coercion.
JSON stringification always results in a string value. Values such as `undefined`, `function`, `symbol`, and any `object` with a circular reference are not acceptable to pass as they are not "JSON-safe" (considered to not be portable to other JSON-compatible languages).
If such a value is found in an array, the value will be replaced with `null`. In an object, it will be excluded, unless that value contains a circular reference, in which case an error will be thrown.
JSON stringification also checks for `object` values equal to a `toJSON()` method, and runs them first to obtain a resultant value for serialization. So if you have an object that won't or may not pass as JSON safe, you can add a `.toJSON()` method to it that defines the values that are safe for the purpose of JSON stringification.
`JSON.stringify` also allows for an optional second parameter to be passed that serves as the "replacer". If you pass an array containing strings of the property key names you want to include as your replacer, you will filter out any properties that weren't included in your stringification. If you pass a function with arguments passed for both your property key and value, you can conditionally only return values that meet your specified conditions. The function argument will be ran once on the object itself before being ran on each containing property.
A third optional argument can be passed to `JSON.stringify` called "space", which allows you to set indention for more human-readable output. You can either set a numerical value equal to the number of space characters for each level of indentation, or you can set a string where up to 10 characters will be used as the indentation pattern.

-`ToNumber`-
`undefined`, when coerces to a number, results in `NaN`, and `null` coerces to `0`.
Strings that fail to be coerced to a number are `NaN`. 0-prefixed octals and bases other than 10 are handled as base-10 decimals in a `ToNumber` operation, unlike `number` literals.
Objects and arrays are first coerced to their primitive value equivalent before following regular `ToNumber` primitive coercion rules.
When converting objects or arrays to a primitive, the `ToPrimitive` abstract operation is called. This operation checks to see if the object has an internal `valueOf()` method. If that exists and returns a primitive value, that is the value that will be used. If not, `ToPrimitive` will try to use `toString()` to provide a coerced value. If both fail to provide a primitive value, a `TypeError` is thrown.
You can create non-coercible objects as of ES5 via means such as `Object.create(null)` that have a hidden [[Prototype]] property of `null` that don't possess either a `valueOf()` or `toString()` method.

-Explicit Coercion-
The advantage of explicit coercion is that it makes it more obvious to other developers that a type conversion has taken place.

-Explicitly: Strings <--> Numbers-
To explicitly coerce a string into a number value or vice versa, you'd pass the value to be coerced into the native constructor of the type you want to coerce to, being sure to leave out the `new` keyword, as this would create an object wrapper. This usage looks quite similar to that in statically typed languages.
Using `toString(..)` needs to implicitly box a primitive value in a wrapper before it can coerce it into a string. Both explicit and implicit.
The unary operation of adding a non-number value without using a left-hand operand coerces that value to a number. The JS community accepts this as an explicit form of coercion, although it's suggested to avoid when other operators may be present.
A unary `-` operation functions the same way but flips the sign of the resulting value. You cannot unflip the sign using `--` as this is reserved for the decrement operator. You'd have to space them out (`- -`).

-`Date` to `number`-
The unary `+` operator is commonly used to coerce a `Date` object into a `number`, as this gives you the date in Unix timestamp format ('var d = +new Date();'). `Date.now()` is preferable for the current timestamp.
Parenthesis on a function call following the `new` keyword are option if no parameters are passed. Some feel that leaving them in improves readability.

-The Curious Case of the `~`-
Bitwise operations first explicitly coerce any non-`number` values into 32-bit `number`s where possible.
The tilde '~' operator, AKA the bitwise NOT, attempts to coerce the given value to an integer using `ToInt32`, and if successful, performs a bitwise negation (flipping parity/twos complement) (basically `-(x+1)`, although `~-1` produces a positive zero). This means the only value `~` can resolve as falsy is -1. 
-1 is called a "sentinel value" (a value given a semantic meaning within a larger set of values). C returns it as a "failure" for many functions. JavaScript returns it when a substring was not found during an `indexOf(..)` operation. This means `~` will resolve a failing return value to the falsy value of zero.

-Truncating Bits-
Double tildes `~~` can be used to truncate the decimal portion of a `number`.
This simply runs the bitwise NOT operation twice, coercing the value to an integer using `ToInt32`, and then fliping bit parity twice, leaving you with a decimal truncation of the same value you provided.
Note this will not work the same as `Math.floor(..)` does when using negative numbers, as the floor of a negative decimal value is the next digit up (-38 is larger than -39), and truncate still simply truncates, leaving you with a difference of one between the two. Also note that `~~` only works reliably with 32-bit numbers.
Alternatively, you can also perform this in a single operation by using `x | 0`.
It's advised to avoid using any of these as explicit coercion mechanisms if those who read and modify your code aren't aware of their meaning.

-Explicitly: Parsing Numeric Strings-
You can parse numerical characters (the first group coming from the left-hand side) out of a string value and coerce them into a number using `parseInt(..)`.
`parseFloat(..)` performs similarly, parsing out a floating number value.
If you didn't provide `parseInt(..)` a second argument with the desired radix pre-ES5, it would attempt to determine the numerical base depending on the beginning characters of the string for a base prefix. If you're going to run your code in ES4 or earlier, provide the radix.

-Parsing Non-Strings-
Using `parseInt` on a non-string will often coerce the value to a string before conducting the parse.
Many unexpected resulst can occur when parsing a string with a radix/base higher than 10, where alphabetical numerics can be parsed out of a string value.

-Explicitly: * --> Boolean-
`Boolean(..)` and the `!` negative unary operator will both explicitly coerce a value to a boolean.
A double negative `!!` is often used to both coerce and ensure the parity is left intact.
Explicit boolean coercion is not necessary if the value is used in a context that demands a boolean. For example, in an `if(..){..}` statement.
Author recommends avoiding the ternary operator for coercion in lieu of the previous two options, if explicitness is to be desired.

-Implicit Coercion-
Implicit coercion isn't necessarily something to be avoided at all times.
It can be quite useful when one has the aim of reducing verbosity, boilerplate, and any unnecessary details that bog code down, preventing one from focusing on the more important intent.

-Simplifying Implicity-
Implicity is to abstract code and improe readability.
Some developers feel that if a mechanism used to hide details can be abused or misused, then it should be avoided altogether.

-Implicitly: Strings <--> Numbers-
When the overloaded `+` operator is used in conjunction with an `object` operand, it will concatenate it with the other operand if it is already a `string`, or if both operands can be resolved to a `string`.
It checks if resolution is possible via the `ToPrimitive` > '[[DefaultValue]]` operations. If the `valueOf()` method check on the array fails to procure a primitive value, a string will be coerced using the `toString(..)` method, allowing for concatenation.
The above steps are the same as when using the explicit `ToNumber` operation.
If neither operands are a string, the operands will be calculated as a numeric addition.
A "commutative" operation is one where a difference in the order of the same values is irrelevant in its affect of the result. `+` numerical operations fit this profile, whereas string concatenations generally do not (adding "" to a number to coerce to a string would be considered commutative).
Keep in mind that implicit coercion to a string using `a + ""` checks the return of the `valueOf()` method on a value whereas the explicit `ToString` simply invokes `toString()` directly. If you are defining your own custom variants of these methods that differ at all on an object, then you may get differing results between these explicit and implicit forms of coercion.
The `-` operator is useful for coercing a string to a number, as the operator is only defined and used in cases of numerical subtraction. The multiply and divide operators are less commonly used for coercion, but also perform a similar utility.
When implicitly coercing to a number using these operators, a similar `ToString` coercion takes place, before being coerced to `number`s.

-Implicitly: Booleans <--> Numbers-
Coercing boolean values to numbers can be useful when checking the truthiness of several values, as you can plug them into a function containing a `for` loop that checks how many flags met your specified condition, adding the truthy booleans as numbers to the sum implicitly via use of the addition assignment `+=` operator. (You can also perform a similar action by using the more concise `.reduce(..)` utility on an array.)

-Implicitly: *--> Boolean-
Implicit coercion to a boolean occurs in the second clause for the `for(..)` header, in `while(..)` and `do..while(..)` loops, and to the left-hand operand of `||` logical or and `&&` logical and operations.

-Operators `||` and `&&`-
These logical operators will only result in the value of one of the two operands they are given (not always boolean). The author believes they should be called "operand selector operators" because they do not always provide a logical (boolean) value.
`||` will attempt to coerce the first (test) value to a boolean. If the coercion resolves to `true`, that operator is what is selected as the result. Otherwise, the second operand value results. Similar to `a ? a : b`.
`&&` works the same, but instead returns the second operand if the first resolves to `true`, and vice versa. Similar to `a ? b : a`.
A difference to keep in mind between using these operators to the ternary equivalents is that with the ternary you may be evaluating your left-hand expression (that may be running a function) twice, versus the one time with the operators, using the operand as both the value to test and the result to provide (with a truthy `||` or a falsy `&&`).
Because of this difference, you should only use the operators when it's ok to skip falsy values. If additional condition checks are needed, the extra evaluation with ternary conditionals allow for further specificity and complexity.
JS minifiers often use `&&` as what is called a "guard operator", in that it protects the execution of a function unless the conditions of left-hand operand test as truthy. Usually, human coders just use an `if(..){..}` conditional to accomplish the same thing.
Putting expressions using these operand selector operators inside of an `if(..)` or `for(..)` conditional works the same way, with the resulting expression value being implicitly coerced into the boolean that will be used to determine whether the enclosed statements will run.

-Symbol Coercion-
While explicit coercion of ES6 Symbols to strings is allowed, the attempt to implicitly coerce them will throw a `TypeError`.
`symbol` cannot be coerced to a `number`, but will coerce to a `boolean` (implicitly or explicitly).

-Loose Equals vs. Strict Equals-
The notion that loose equals checks for matching values and strict equals checks both matching values and types is a misconception. The only real difference between the two is that loose equals allows coercion while the other does not.

-Equality Performance-
Knowing this, you can see that `==` loose equals actually does more work than `===` strict equals (if the types are different), compared to the common idea that loose equals is actually less intensive of an operation. The performance difference is negligible, though.
Both operands still check types. Only one will try to coerce differing types.

-Abstract Equality-
The `==` loose equals operator is defined as the "Abstract Equality Comparison Algorithm" in the ES5 spec.
These rules of "abstract equality" define how coercions should occur for every possible combination of types.
Both loose and strict comparison of `objects` are the same in that the result is equal only if both objects are references to the exact same value.

-Comparing: `string`s to `number`s-
When loose comparing a string to a number, the `string` is always coerced to the matching `number` type.
The spec uses capitalized names for types, such as `Number` and `String`, even when referring to primitive types (not be confused with native functions).

-Comparing: anything to `boolean`-
With loose equals comparisons where one value is boolean, the boolean will always be coerced to its `number` value equivalent.
Because of this, you are not checking the truthiness of a value when comparing a different value type, but rather checking if a value is equal to the numerical value of the boolean.
If checking for truthiness, it's still best to use either the implicit ( `if(x)` ) or explicit ( `if(!!x)` or `if(Boolean(x))` ) boolean coercions.
Recommended to avoid loose comparisons to boolean values.

-Comparing: `null`s to `undefined`s-
`null` and `undefined` are indistinguishable in loose comparisons, coercing to one another.
You can use the `null` comparison to check if a function returns that or `undefined` as a value, and be assured that no other values would give off a false match. Implicitly, this is safe and far more readable.

-Comparing: `object`s to non-`object`s-
Objects will have `ToPrimitive` called on them to attempt coercion of a simple scalar primitive when they are loosely compared to numbers or strings (booleans coerce to numbers first).
This functions similarly to unboxing a primitive value from an object wrapper.
Note that this will not work with `null` or `undefined`, which have no object wrapper, or with `NaN`, which can never equal itself.

-Edge Cases: A Number By Any Other Value Would...-
By changing the `valueOf` method of `Number.prototype` to return a specific or incrementing number, you can get strange looking results when comparing a `new Number(..)` variable to a primitive number.
Author states these corner cases are sometimes used as an argument against coercion.

-False-y Comparisons: The Crazy Ones-
Coercion of an array containing `null` to a string will result in an empty string.
Coercion of any whitespace combination, empty string, or empty array to a number will result in a "0".

-Safely Using Implicit Coercion-
An alternative operator to use is `typeof` to avoid what you would consider to be false positives for your matching operations. Implicit coercion will not occur with `typeof` and it will always return one of seven types.
https://github.com/dorey/JavaScript-Equality-Table - table of JS equality comparison matches.

-Abstract Relational Comparison-
When comparing strings in relational comparisons that remain strings, a lexicographic comparison will occur, where each alphabetical character is counted as a numeric value and compared in the order of left-most to right-most characters.
When comparing two separate object references containing equal (but still separately instanced) values, you will only get a "true" result when conducting a `<=` or `>=` comparison. This is because two objects will only loose/strict-equal one another if they point to the exact same value location (not duplicates of the same value), they are not "less than" or "greater than" one another seeing as they both resolve to the same `["object Object"]` string value, and the `<=` and `>=` are not actually "less-than/greater than or equal to".
`<=` is actually defined in the spec as "not greater than", simply checking if `>` results to false, and likewise for the opposite operator.
There is no way to prevent implicit coercion from occuring with relational comparisons, so explicitly coerce your values to the desired matching type first if you need to.

===========================================Chapter 5===========================================
Grammar

-Statements & Expressions-
You can think of statements as sentences, expressions as phrases, and operators as conjunction and punctuation.
Every JS expression can be evaluated to a single result.
`var blah = blah` would be considered a declaration statement, and can contain assignment expressions.
An expression statement just contains an expression (condensable to a single value).

-Statement Completion Values-
All statements have completion values, even if they are `undefined` (variable assignments return this, for example).
For any block-scoped (`{..}`) code snippet, the completion value implicitly returned is the completion value of the last statement/expression is contains.
CoffeeScript works similarly, in that it implicitly returns values from functions that are the same as the last statement in that function.
In JS, you cannot directly capture the completion value of a statement and assign it to a variable. Other than using the less than desirable `eval(..)` method, there is an ES7 proposal for a `do {..}` expression that would allow for more direct application of completion values resulted from the contents of its enclosing block. In effect, this would treat statements more like expressions so that they can be added inside of other statements.

-Expression Side Effects-
An expression side effect is basically any changes made that aren't reflected in the completion value. This can occur in function calls or when postfixing increment/decrement unary operators to the value in an assignment operation (this would result in the assignment taking place before incrementing the value, which may be another variable's value).
You cannot use both pre and post-fixed unary operators on the same variable, since they need to be performed on a variable, and running one of them (post-fixed occurs first) resolves the variable to a plain number, resulting in a `ReferenceError` once the pre-fixed operation attempts.
Wrapping an "after" side effect in a parenthesis pair does not define a new wrapped expression to be evaluated after execution of the post-fixed side effect. Post-fixed unary operations always occur after value assignment.
The statement-series comma operator allows you to string multiple standalone expressions with one statement to be evaluated. This allows for an expression to be evaluated by all previous comma-delimited expressions are evaluated before it sequentially. This means that any post-fixed side effects upon a variable will have been applied when evaluating that same variable further ahead in that statement series.
The `delete` operator returns a value of `true` on both nonexistent properties and existing, configurable properties of objects. Its property deletion utility is a side-effect of the operation that provides this completion value.
The assignment operator itself has a side-effect of assigning a value to a variable, as the completion value is merely a return of the value that was assigned. The same applies for compound assignment operators.
The completion value of an assignment operation being equal to the evaluated value being assigned is useful in instances such as chaining of assignments, as each preceding assignment will be equal to the completion value evaluated from the assignment expressions that follow it. Ensure your variables are all being declared beforehand, as they cannot be declared inside of the right-hand assignment itself. If a referenced variable in a chain assignment operation is not declared, a `ReferenceError` will be thrown in strict mode, or an accidental global variable will be created.
Another use of assignment being a side effect is that you can combine multiple `if` statements. Wrap your additional `if` assignments in matching parenthesis and include them as conditionals in your single `if`. They will assign as a side effect and be evaluated as true or false in the context of the `if` conditional, being implicitly coerced to a boolean.

-Contextual Rules: `{ .. }` Curly Braces: Object Literals-
Enclosing curly bracket pairs, when assigned to a variable, are referred to as an `object` literal.
The variable being assigned to is sometimes called the "l-value", whereas the object literal being assigned is called an r-value.

-Labels-
When you remove the target l-value in an object literal assignment, you are left with regular, block-scoped code.
Any key/value pairs in a standard block of code are known as labeled statements. The "key" is the label, and the "value" is the statement.
JS has a special form of the `goto` statement named "labeled jumps", which `continue`s either the loop specified by label, or if not specified, the one enclosing the `continue` statement.
You can also `break` a specific label to continue after the end of that loop.
While a label can apply to a non-loop block, `break` is the only statement out of the two that can reference such a label, as you cannot `continue` a non-loop block.
Labeled loops/blocks are best avoided, as it is usually better to use function calls in place of loop jumps.
Statement labels can't have `""` quotes around them. This means JSON is not valid JS grammar on its own, but rather a subset of JavaScript syntax. JSON values by themselves throw an error because they are interpreted as statement blocks with invalid labels. JSON-P (which is the act of wrapping JSON values in a function call) makes JSON data valid JS grammar because it treats it as an object literal value being passed to the function object.

-Blocks-
Adding an empty object to an empty array results in the string value `"[object Object]"`, because the array is first coerced to an empty string, and then the object is coerced to its string value as well.
Adding an empty array to an empty object results in the number `0`, because the `+` operator is adding the standalone coerced array value (`+ []`) of `0` to what it perceives to be an empty block (as blocks don't need semicolons to be terminated).

-Object Destructuring-
Curly brackets can also be used in ES6 destructuring assignments. With `object` destructuring, you return an object from a function that contains a series of key/value pairs. You can then assign the function to an object with matching keys defined, and have that return populate those keys with their matching values.
You can create functions that accept objects using destructured assignments as well.

-`else if` and Optional Blocks-
There actually is no `else if` clause. They are simply a combination of `else` and `if`.
These statements do not need brackets around their associated block if it only contains a single statement. This means that any instance of `else if` occurring is actually an `if` statement being defined inside the block of an `else` statement.

-Operator Precedence-
The `=` operator has precedence over the `,` comma operator (in fact, the comma operator has the lowest precedence of all), so when using `,` as a statement-series operator, it is likely necessary to wrap the statement in parenthesis, otherwise whatever comes first in the series after the `=` operator will be assigned before any after side effects occur.
The same thing is of importance with logical operators, as they have higher precedence over both `,` and `=` operators.
`&&` operators are more precedent than `||` operators.

-Short Circuited-
With logical AND and OR operators, the right-hand operand will not be evaluated if the left-hand operator is sufficient enough to determine the outcome of the operation (false and true, respectively).
This can be useful in an instance where you passing an object to a function, and want to check for the existence of a property. If the object doesn't exist, checking for a property on it will throw an error. Using the AND operator, you can check for the object's existence (or at least that what was passed resolves to a boolean of `true`), and avoid errors on checking the property if a value of `false` is evaluated on the left-hand.
Similar can be conducted with the OR operator, avoiding the call to a function on the right-hand side of the operand if the left-hand resolves to `true`.

-Tighter Binding-
Logical operators have more precedence over ternary operators.
They are commonly explained as "binding more tightly" than ternary operators.

-Associativity-
Operators are generally left or right-associative, meaning they group from the left or the right. This is important when there are groups of the same operations occurring in sequence. You want to know which direction these groups will be evaluating from first.
`||` and `&&` are left-associative.
Ternary operators are right-associative, which means the right-most groups actually evaluate first. This is important because even if you attain the same results regardless of grouping, the expressions to be evaluated will differ, which could have implications if, for example, function calls are involved in the evaluations.
The `=` operator is also right-associative.

-Disambiguation-
Author recommends to make use of operator precedence and associativity when it leads to less verbose and cleaner code, while using manual `( )` grouping in more complex operation chains where clarification would be of aid, such as when using multiple sets of (conditional) ternary operators.

-Automatic Semicolons-
ASI (Automatic Semicolon Insertion) assumes there is a semicolon in places where you did not put one, but its usage is implied, in order to prevent parser errors from being thrown. It can only occur in places where a newline takes place.
Statement blocks do not require semicolon termination.
ASI can be handy when using the `break`, `continue`, `return`, and `yield` keywords, as they are often used with no right-hand value. ASI prevents the contents of the next line being combined into a single expression with these keywords.

-Error Correction-
Since JS doesn't really possess "significant newlines" and ASI is considered "error-correction", the author (and even the creator of JavaScript) state it best to avoid using ASI for the purposes of stylistic preference. Use semicolons where you know they are to be needed.

-Errors-
Early errors are caught and reported during compile time. Syntactical errors fit this profile, as does some syntactically-acceptable but grammatically disallowed code, such as invalid regex, assignment to a value rather than an identifier, and (in strict mode) the declaration of duplicate parameters in a function or duplicate properties in an object literal.
Even though they are more grammatical errors than syntax, you will still get a `SyntaxError` thrown for these pre-defined error conditions.
Early errors cannot be caught with `try...catch`, as they never make it to execution.

-Using Variables Too Early-
The "TDZ" (Temporal Dead Zone) concept defined in ES6 as a place in code where a variable reference cannot yet be made because it hasn't been initialized yet.
This can occur when referencing a block-scoped variable that hasn't yet been initialized with the `let` keyword.
While `typeof` has an exception for undeclared variables (resulting in `undefined`), it will throw a `ReferenceError` when used to reference a variable in the TDZ.

-Function Arguments-
TDZ violations can also occur with ES6 default paramater value definitions that reference themselves or an outer reference outside of scope.
While there is no difference between passing `undefined` or omitting an argument with default parameters, you can still tell the difference between the two by calling the `arguments.length` method within the function. This checks the number of slots in the `arguments` array that have entries. If you explicitly pass `undefined`, it will be added to the `arguments` array, even if a different default value is used.
The `arguments` array can contain different arguments that what are actually used for values in a function, even in ES5 strict mode, by redeclaring the value of the parameter in the function body. This will create an "unlinked" argument.
In non-strict mode, `argument` array values and their respective parameter variable values will always be "linked" to match, so updating the latter will also update the former.
This linkage is considered a leaky abstraction that reveals an implementation detail rather than an intended feature, and its usage as such should be avoided, especially since usage of the `arguments` array is now deprecated as of ES6 (in favor of `...` rest parameters).
In pre-ES6, `arguments` still has its utility (it was the only way to get all arguments passed to a function, including those that were not assigned to parameter variables), but don't refer to a named parameter and it's matching argument in the same place.

-`try..finally`-
When using a `try..finally` clause, anything returned from the `try` will be ran before `finally` (which always runs regardless of what happens with `try` and `catch`, if present), but not returned until completion of the enclosing function call. The same behavior occurs if you use a `throw` inside your `try`, where that will become the completion value for that function.
If you `throw` or `return` from `finally` as well as from `try`, the completion value returned from the enclosing function will resolve to what you returned in `finally`, essentially overriding what was returned from `try`.
Control statements such as `break` and `continue` will behave similarly when used in a `try..finally` clause.
ES6 adds `yield` statements, which function as intermediate `return` statements. They are not completed until their generator is resumed, so using one inside of a `try` will not immediately result in the execution of the `finally` clause.
One note is that the omission of a `return` inside of a `finally` does not operate similarly to the behavior of a function where the lack of an explicit return results in the implicit `return undefined` being returned. The previous `return` call remains intact.

-`switch`-
The `switch` statement uses strict equality `===` comparisons when matching values to cases. To allow loose, coercive equality `==`, you can test each case expression (performing a loose equals comparison) result against a test expression of the boolean, `true`. The `switch` will still be strictly matching the boolean results, but your individual `case` expressions will perform the coercive comparison.
Be careful doing this with expressions that include logical operators that test for truthiness. For example, an OR operation that has a string operand would qualify as truthy, resulting in that string being returned. You must explicitly force it to a boolean of `true` or `false`.
The (optional) `default` clause doesn't have to be added to the end.

-Review-
Expressions can have side-effects or they can be pure and unaffecting of outside data.
The context in which syntax is used and utilized can vary based on the grammatical rules of the JavaScript language.
Operator precedence is the order in which they will bind (before or after others) and operator associativity is the implicit order in which those operations are grouped.
Early errors are often syntactical (but sometimes semantical rule-breaking), compiler-thrown, and uncatchable, whereas run-time errors can be caught with `try..catch`.
Avoid using the `arguments` array when possible, as there is leaky abstraction behavior that especially surfaces when referencing both the argument slot and its (not always) matching named parameter.
The `finally` clause, with its execution order intricacies, can be useful, but also confusing when combined with labeled blocks.

===========================================Appendix A===========================================
Mixed Environment JavaScript

JS always depends on a host environment, each of which can potentially cause different types of unpredictable behavior with your code.

-Annex B (ECMAScript)-
JavaScript is the name for the browser implementation of ECMAScript.
Annex B is the ECMAScript spec for JS compatibility in a browser host environment.
The primary compatibility differences are: 1. Octal number literals are allowed in non-strict mode.
`window.escape(..)` and `window.unescape(..)` allow you to escape/unescape strings containing %-delimited hex escape sequences.
`String.prototype.substr`, in comparison to `String.prototype.substring`, is the same other than the second parameter being equal to the desired character length for the substring, rather than the ending character index.

-Web ECMAScript-
Web ECMAScript covers the gap between Annex B, and what is required of browsers to be compatible with one another in their JS implementation.
(these may be out of date and included in Annex B): `<!--`/`-->` are valid comment delimiters when used on a single line.
Rarely used, as most prefer and encourage the use of other utilities and built-in DOM APIs, there are numerous `String.prototype` additions for formatting HTML-friendly strings.
`RegExp` extensions for match groups and most recent match.
(Already deprecated) `Function.prototype` additions of `arguments` and `caller`.
These and the Annex B deviations are rarely used, but be aware when you use them.

-Host Objects-
Host objects are objects and functions that are built into the hosting environment and provided to the JS engine.
Some of these objects are special in that they have a different internal `[[Class]]` value and come with predefined (and frequently unmodifiable) properties. An example of this is a DOM element.
Some of these host objects will actually coerce to `false` rather than `true`, won't have access to your typical built-in `object` utilities, are partially or completely read-only, contain methods that are unchangeably `this`-bound, etc.
One example of a host object is `console`. This object is provided by the hosting environment, such as your browser's developer tools.
