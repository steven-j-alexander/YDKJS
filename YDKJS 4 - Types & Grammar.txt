===========================================Chapter 1===========================================
Types

A rough definition of a type in JavaScript is: "an intrinsic, built-in set of characteristics that uniquely identifies the behavior of a particular value and distinguishes it from other values, both to the engine and to the developer."

-Built-in Types-
The seven built-in JS types are: null, undefined, boolean, number, string, object, symbol (new in ES6). All of these are considered primitives, except for `object`.
The `typeof` operator inspects a given value and returns the type. `null` is buggy and returns a value of `"object"`. It should return `"null"` but the bug has existed for so long that changing it would cause a lot of harm to legacy code, so it is left as is.
To test a `null` value using its type, you need to create a compound condition that, in addition, checks the value's falsiness, as `null` is the only "falsy" primitive value that returns a `typeof` of "object".
Functions, although considered a subtype of `object`, are also identified by `typeof`. Functions are considred "callable objects" in JS, as they have an internal [[[Call]]] property, allowing them to be invoked.
Because functions are objects, they can have properties, which include the parameters they were declared with. This is useful if you want to run an object utility such as `.length` on a function.
Arrays are also considered a subtype of `object`, with the included ability to be numerically indexed.

-Values as Types-
Values have types in JS, rather than variables. Variables can hold any value, therefore they can hold any type.
The type of value a variable can hold is mutable. You can think of this as JS not having "type enforcement".
A value's type cannot be changed. Coercion is the act of creating a new value from a value of a different type. `typeof` is simply checking the type of the value contained in a variable.

-`undefined` vs "undeclared"-
A variable that has been declared, but currently has no other value associated with it, has a value of `undefined`.
An undeclared variable is a variable that has not been formally declared in the accessible scope.
Some browsers will return a warning that a variable has not been defined when in fact it hasn't even been declared. The `typeof` operator also has a safeguard that engages in a similar behavior, so be aware.

-`typeof` Undeclared-
The `typeof` safeguard is handy when checking for the existence of a variable or a function without throwing an error, especially in instances where multiple script files can load variables into shared global namespace.
Recall that `if` statements are only block-scoped, so if you are performing a `typeof` check where "undefined" results in an assignment operation, you want to be sure to avoid preceding your declaration with the `var` keyword, as this would hoist the declaration to the top of the enclosing scope, even if the `if` condition fails. When defining a polyfill for special types of built-in global variables, sometimes referred to as "host objects", or variables specific to particular browses, this could cause an error pertaining to duplicate declaration.
All global variables are also properties of the global object, which in a browser is essentially the `window` object, so you can also perform safe checks for global vars in `if` conditionals using `window.prop` syntax. No `ReferenceError` is thrown on trying to access object properties that don't exist. Some developers prefer to avoid this though, as accessing the `window` object directly can be unwise if your code needs to run in multiple JS environments (such as node.js).
`typeof` is useful for checking the existence of variables in places other than the global object as well, although some developers prefer using dependency injection. If you wanted to check and see if program or module contained a particular helper utility before adding it in, you can check for the `typeof` said variable. If the check fails, you can have a default anonymous function defined and ready to go.
The dependecy injection design pattern is similar, but instead of implicitly checking for the feature/variable directly around it, you would need to have the dependency explicitly passed into the function that performs the check (which now simply checks if anything was passed to it).

===========================================Chapter 2===========================================
Values

-Arrays-
Like type-enforced languages, JS `array`s are simply containers that allow storage of any type of value. Pre-sizing is not necessary.
Using the `delete` operator on an array will remove a slot from it, but does not update its `length` property. Also, creating "sparse" arrays (leaving empty/missing slots) will still leave a `length` equal to the highest index, plus 1 (for the "0" index). Slots you haven't defined will have the same behaviors as a slot that has been explicitly defined as `undefined` would.
`string` keys/properties added to an array object do not have an impact on its `length`, UNLESS the `string` value can be coerced into a base-10 numerical value, in which case the value will be treated as the numerical index. Because of this (and the fact that general objects exist), it's best to use objects for storing key/value pairs.

-Array-Likes-
There are instances where you will need to take "array-like" collections of values and coerce them into actual arrays to be operated upon using the array object utilties. Many DOM query operations return array-like collections, as well as the ES6-deprecated function `arguments` object. One easy way to do this with `arguments` is to make a function that assigns a call of `Array.prototype.slice.call( arguments );` to a variable, and then call that function while passing your list of arguments.
In ES6, you can instead use `Array.from(..)` to perform the same task of taking anything passed to it and coercing it into a new array.
`.push` allows you to add more values to an array.

-Strings-
JS strings are not really the same as arrays of characters. JS strings are immutable, whereas arrays are not.
Older versions of IE did not allow for index-style character access on strings. The correct approach is considered to be `string.charAt(..)`.
Because strings are immutable, all string methods that alter contents are actually returning a new `string` each time, while many of `array`s manipulation methods do modify content.
Due to these differences in mutability, any `array` methods that directly alter existing values cannot be used on `string`s, but anything non-mutable that returns a new value can be "borrowed".
A quick hack to reverse a simple string to convert it to an array, use the `reverse()` utility, and then convert back to a string: `string.split( "" ).reverse().join( "" );`. You'd need more complex utilities to perform the same operation with strings containing complex unicode characters.
If you are performing a lot of operations on a set of strings that require you to treat them like arrays of characters, you should probably just make them arrays of characters, simply `join("")`ing them whenever you need to represent them as strings.

-Numbers-
`number` is the only numeric type currently availed in JS. It encompasses both integers and fractional values. JS uses double-precision format floating-point.
You can read about IEEE 754 to understand how these numbers are stored in memory.

-Numeric Syntax-
The leading and trailing portions of a decimal value are optional (".42" or "42.").
Very large and small numbers will be outputted in exponential form by default, providing the same output as the `toExponential()` method.
`number` values, having the ability to be boxed into the `Number` object wrapper, are availed access to utility methods built into `Number.prototype`.
`.toFixed(..)` allows you to specify how many decimal places you want a value to be displayed with as a `string` representation.
`.toPrecision(..)` works similarly, but allows you to specify how many significant digits can be used to refer to a value, meaning you can set it to a smaller number of digits than the real value, causing them to round up or down.
You can use these `Number` methods direct against numerical values, but recalling that a decimal point without a trailing value is acceptable syntax in JS, you have to be certain the value contains a decimal point (in addition to the dot operator that notates a separation between the value and the property call), or that you wrap the value in a parenthesis, in order to avoid a `SyntaxError`. It is uncommon to access property methods directly on primitive values, so this is not likely to be seen often. You can also validly exclude the decimal point and instead include a space between the value and the dot operator, but this is not recommended by the author.
You can define numerical values with decimals when using exponent form. ie. `1.7E4` is equal to `17,000`.
Express `number` literals in other bases than 10 by preceding a value with `0x` or `0X` for hexadecimal, a `0` for octal pre-ES6 or `0o`/`0O` in ES6+, and `0b`/`0B` for binary. Author advises to stick to the lower-case letter syntax for readability.

-Small Decimal Values-
With IEEE 754, binary floating-point is not perfectly precise, which can lead to comparisons of equations using fractional values failing equality comparisons to what should be their resulting values.
The most acceptable way to get around these sorts of situations is to use a small rounding error as the comparison's "tolerance". This value is often called the "machine epsilon", usually 2^-52 for JS `numbers`.
As of ES6, this tolerance value is now predefined with a constant-style identifer of `Number.EPSILON`. You can also polyfill it using `Math.pow(2, -52)`. You can create a function that, taking both values as arguments, checks to see if the absolute of the difference between these two values is less than the tolerance value of `EPSILON`.
The max value that can be represented is 1.798+e308, or `Number.MAX_VALUE`. The minimum representable value is `5e-324`, or `Number.MIN_VALUE`.

-Safe Integer Ranges-
The range of values that is considred "safe" for whole integer `number`s is smaller than the range one would infer by `Number.MAX_VALUE`. That value is `2^53 - 1`, or 9007199254740991, just over 9 quadrillion. It is defined in ES6 as `Number.MAX_SAFE_INTEGER`.
The minimum safe integer is also defined in ES6 as `Number.MIN_SAFE_INTEGER`, and is equal to -9007199254740991, which is just a subtraction of the max.
A common encounter caused by this limitation comes in dealing with 64-bit IDs from things such as databases, which exceed safe value bounds. Because of this, they must be stored as `string`s. If math operations are to be performed on such large values, a "big number" utility would be required.

-Testing for Integers-
ES6 includes a utility to check if a value is an integer: `Number.isInteger(..)`. It basically checks if the value is 1. a number and 2. has a modulus of zero when divided by one.
Another ES6 utility for checking if a value is a "safe integer": `Number.isSafeInteger(..)`, which performs the same check as `Number.isInteger(..)`, but also ensures the absolute value of the passed value is less than or equal to the value of `Number.MAX_SAFE_INTEGER`.

-32-bit (Signed) Integers-
Numeric operations such as bitwise are defined for 32-bit numbers, which are even smaller than the safe range. That range is between `Math.pow(-2,31)` and `Math.pow(2,31)-1`.
You can force a number into a 32-bit signed integer value by using the bitwise OR operator (`val | 0`). Since the bitwise operator can only handle 32-bit integer values, any excess bits will be thrown out. OR'ing the remaining value with zero is essentially a no-op (no operation).
Passing certain values such as `NaN` and `Infinity` will pass through an abstract operation called `ToInt32` and end up with a value of `+0` when passed to a bitwise operator, and are considered to not be 32-bit safe.

-Special Values: The Non-`value` Values-
`null` is an empty value or had a value that it doesn't hold anymore. The label and value are both `null`. 'null' is a special keyword, rather than an identifier. You can't assign anything to it like a variable.
`undefined` has not had a value yet or can be considered to be missing. The label and value are both `undefined`. `undefined` is also an identifier.

-Undefined-
Outside of strict-mode, you can actually assign a value to the global `undefined` identifier.
In either strict or non-strict mode, you can make a local variable named `undefined` and assign a value to it.
Don't do either of these.

-`void` Operator-
Another way to get the `undefined` value is via the `void` operator. It "voids" out any values returned by the expression on the right-hand of the operand, always resulting in a value of `undefined`. Note it does not modify the existing value, only returning `undefined` for that `void`ed expression.
To represent `void` as a standalone `undefined`, you would use the conventional `void 0`, although there is no practical difference between this and any other resulting voided value.
`void` could be used in a return statement that included a `setTimeout(..)` that ran if a condition failed, ensuring no value was returned that could have potentially resulted in a false positive, although you could just separate those two actions.
A need for `void` is rare.

-Special Numbers: The Not Number, Number-
Not using a `number` for either operand in a math operation will result in a value of `NaN`. Author states it better to consider `NaN` to be "invalid number", "failed number", "bad number", rather than "not a number", seeing as the `typeof` `NaN` still resolves to `number`. `NaN` can be considered a special error condition within the set of normal `number`s.
`NaN` is never equal to any other `NaN` value (including itself). It is the only value in JS that is not reflexive.
There is a global built-in utility called `isNaN(..)` that is intended for checking if a value is `NaN`, but it (buggily) just checks if a value is literally a valid number or not, so caution advised.
In ES6 there is a new and improved replacement utility called `Number.isNaN(..)` that *actually* checks if a value is `NaN` or not. One polyfill for this would simply perform the same global `isNaN(..)` check, but would also require that the value was still a `number` in order to pass. An even simpler polyfill would be to compare the value to itself, recalling that `NaN` is not a reflexive value, and will only pass if it fails this comparison.

-Infinites-
Math operations resulting in infinite numbers do not throw compiler errors like traditional compiled languages, as JS has an `Infinity` (or `Number.POSITIVE_INFINITY`/`Number.NEGATIVE_INFINITY`) value.
Negative infinity results from equations where one, but not both, of the operands are a negative value.
Due to the numeric limitations of IEEE 754 floating-point, you can get a return value of `Infinity` even with operations such as addition or subtraction.
IEEE 754's  "round-to-nearest" mode will cause a number just under max value, when added to a max value, to round back down to max value, rather than up to `Infinity`, as it computes that as being the closer value.
You cannot math a value from `Infinity` back into a finite value.
`Infinity / Infinity` equals `NaN`.
A positive finite `number` divided by `Infinity` equals 0.

-Zeros-
Negative zero (`-0`) results from multiplying or dividing a negative number by zero. It cannot result from addition or subtraction operations.
Some older browsers still report this value as a simple zero. The spec also requires that converting a negative zero to a string will result in a string form of positive zero (`0`). The same requirement does not apply when working in reverse. This also occurs when using the `JSON.stringify(..)` method, with `JSON.parse(..)` converting negative zero strings into the proper negative zero `number`.
This deception also applies to comparison operators. According to them, `-0 === 0`.
To check if a value or expression is equal to negative zero, you'd need to write a function that both checks if the value is zero, and then checks if a value of 1 divided by that zero is equal to `Number.NEGATIVE_INFINITY` (`-Infinity`).
It may seem useless to know this, but there are some applications where negative zeros are utilitized, such as in denoting the direction of movement in an animation frame. Preserving the sign can prevent the unwanted loss of information in such a circumstance.

-Special Equality-
In ES6, there is a new utility called `Object.is(..)` that can test two values for absolute equality, including the special values mentioned.
This performs an equality check while combining the `NaN` and `-0` checks of the previously mentioned ES6 utilities into one method.
Try and use `Object.is(..)` only where these special cases may be encountered, as using simple comparison operators are likely more efficient.

-Value vs. Reference-
In other languages, you can syntactically specify whether a value is assigned or passed by means of value-copy or reference-copy.
In C++, you can pass a variable into a function and have its value updated by declaring a function parameter (`int& myNum`). When you pass a variable into the function, `myNum` will now reference that variable, similarly to how a pointer works. Without a reference parameter, the value passed in will simply be copied, regardless of its complexity.
In JS, there are no pointers. There are references, but they are simply variables pointing at shared values. You cannot refer one JS variable to another, only to values.
The only thing that determines whether a value will be value or reference-copied in JS is the type of value being passed.
Simple values (scalar primitives) are always value-copied: `null`, `undefined`, `string`, `number`, `boolean`, and `symbol`.
Compound values (`object`s and any `object` subtypes) are reference-copied on assignment/passing. There is no hierarchy for variables that share these value references. They are equal peers.
Reassigning the value of a variable that was previously assigned a compound value reference will not change the reference or value of any of the other variables pointing at that initial compound value reference.
To pass a compound object by value-copying, you would need to manually copy it yourself. For arrays, you can pass them into a function using `a.slice()`.  `.slice()` creates a shallow copy of an array when no overload parameters are provided.
To pass a scalar primitive value as a reference-copy, you would need to wrap it in another compound value, such as an object or array.
Reference-copying a scalar primitive value boxed in its respective object wrapper (`Number` for `number`, etc.) and then passing that to a function in hopes of being able to modify the value referenced is a no-go. The values contained in these object wrappers are immutable, and any variable references them would have to create a new `Number` in order to reference any other value. Attempting to modify a `Number` reference "unboxes" the value from the `Number` object, resulting in the modified value being directly (and separately) referenced by the variable.
You can only add properties on top of a scalar primitive object wrapper such as `Number`.
You are better off just manually wrapping objects in order to reference-copy, as previously suggested.
