===========================================Chapter 1===========================================
What is Scope?

-Compiler Theory-
JS is technically a compiled language. Here is a broad, simplified version of what the JS engine is doing during compilation:
Tokenizing/lexing: A compiled language is tokenized/lexed, which breaks each string of characters into chunks called tokens. If the tokenizer invokes stateful parsing rules to check if a token should be considered distinct or part of another token, this would be called lexing.
Parsing: Takes a stream (array) of tokens and turning them into a tree of nested elements that represent the grammatical structure of the program. The tree is called an AST (Abstract Syntax Tree).
Code-Generation: This process takes the AST and turns into into executable code. This will vary greatly between language used and target platform. This step would create the actual variables in memory on the host machine, store values, run machine code, etc.
JS doesn't have plenty of time to optimize, as it is compiled right before being used, so it uses a lot of tricks (like JITs) to ensure the fastest possible performance.

-Understanding Scope-
Engine: start-to-finish compilation and execution.
Compiler: handles parsing and code generation for engine.
Scope: collects and maintains LUT for all declared identifiers and based on that enforces a set of rules of how code can be accessed.

-Back and Forth-
How the engine approaches a var declaration
1. Compiler checks if there is already a var of that name within the same scope. If so, it ignores the declaration. Otherwise, it asks Scope to declare a new var for that collection.
2. Compiler produces the code for Engine to later execute. Engine will ping Scope to see if there is a var with the same name in the Scope collection. If not, it looks elsewhere (using nested scope). It then makes an assignment if one was specified in the original code.

-Compiler Speak-
Looking up a var is an LHS (left-hand side) lookup. An RHS lookup would retrieve the source value of a given var container.
console.log(a) would be an RHS lookup, as you are looking up the value of a. a = 2 would be an LHS lookup, as you are searching for variable 'a' as a target to assign the value of 2 to.
The compiler handles function code in such a way that it both declares and defines the value in code generation, so that no assignment (or LHS lookup) is required during engine execution.

-Quiz-
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );

Identify all the LHS look-ups (there are 3!).
c = 
a = 
b = 

Identify all the RHS look-ups (there are 4!).
foo( 2 ) {
= a
return a
+ b

-Errors-
When conducting an RHS lookup, if no matching variable is found in the nested scopes, the engine will throw a ReferenceError (of type ReferenceError).
If you cannot find a matching var when using an LHS lookup while not in strict mode (which disables automatic implicit global var creation), a global variable of the same name will be created automatically by the global scope before passing it back to the JS engine.
If you find a variable using an RHS lookup, but do something with the value that is impossible such as trying to run a non-function value as a function or reference a property on a null/undefined val, the JS engine will throw a TypeError.
ReferenceError = Scope-level failure
TypeError = Scope-level success, illegal action occurred

-Review-
LHS reference: for assigning to variable
RHS reference: for retrieving variable value
When the engine first compiles a piece of code such as 'var a = 2', it first tokenizes/lexes the code into the statements 'var a', which is a scope declaration, and secondarily, 'a = 2', which is an LHS lookup of variable a (if found), followed by an assignment operation.
Reference lookups start at the currently-executed scope and work their way up the nest until they reach the global scope, either locating the reference or not.

===========================================Chapter 2===========================================
Lexical Scope

-Lex-Time-
Lexical scope is scope that is defined during lexing, which means it is based on where variables are blocks of scope are authored during writing. Scope is mostly set in stone by the time the code is being lexed.
There are ways to modify scope after lexing, but it is best practice to avoid this and stick to lex-scoping.
Function parameters are included in the nested scope contained within that function.

-Look-ups-
Shadowing is when the same identifier is specified in multiple levels of nested scope (the inner identifier shadows the outer one).
Global variables are automatically properties of the global object ('window' in browsers), so can be referenced as properties of that global object. This allows access to global properties that may otherwise be shadowed by identifiers of the same name located in deeper layers of scope.
Non-global shadowed vars cannot be accessed.
Lexical scope of functions are only defined by their location
The lexical scope lookup process is only applied to first-class identifiers like a, b, c, etc. Referencing identifiers as properties like foo.bar.baz will result in the first identifier being looked up using lexical scope, with the remaining sub-identifiers being accessed as properties using object-property access rules.
