===========================================Chapter 1===========================================
Asynchrony: Now & Later

-A Program In Chunks-
A JS program consists of several chunks, with some chunks running in the "present", and the rest running "later". A common type of a chunk unit is a function.
Asynchronous tasks do not block until completion, whereas synchronous tasks do. Ajax requests complete asynchronously. Requests are made in the present and the results are returned later.
The simplest way to block and wait from now until later when a return is recieved is to use a callback function.
While it is possible to make Ajax requests synchronously, it locks the browser UI, preventing user interaction. It is best avoided.
"Later" (asynchronous) code chunks are often functions that are set to run as a response to specific circumstances (timer or click event, Ajax response, etc).

-Async Console-
Until ES6, all asynchrony in JS was actually handled by the hosting environment. The JS engine would merely run the code chunk it was given. Hosting environments themselves were engineered to handle multiple chunks of JS code (and return their values), executing them over time, in accordance with their internal event loop. This means the surrounding environment is what has traditionally handled all event scheduling.
When making an Ajax request to fetch data from a server, you would set up a response code in a function (referred to as a "callback"). The JS engine suspends the execution and sends instruction to the hosting environment to suspend execution of the response function until completion of the network request, essentially requesting it "call" the function "back" once it retrieves (or fails to retrieve) the appropriate data. The browser itself listens for a response from the network, then schedules the execution of the callback function by inserting it into its event loop.
Each iteration of this callback event loop is called a "tick". During each tick, the loop checks if an event is waiting on the queue. If so, it is removed from the queue and the chunk is executed by running the function callback within the JS engine.
`setTimeout(..)` doesn't directly put your callback on the event loop queue. It sets a timer that, once expired, places the provided callback into the event loop for a future tick of the loop to execute. Even events not a part of your program can be added onto the hosting environment's queue loop as well. This is why the functions you pass it don't always fire with perfect accuracy.
As of ES6, the loop queue is now within scope of the JS engine in addition to the standard hosting environment accessibility/management. The primary reason for widening the breadth of control is for the usage of ES6's Promises, which require direct and specific control over event scheduling.

-Parallel Threading-
While async refers to the gap between now and later (scheduled and ran in serial), parallelism is about simultaneous execution.
Parallel computing commonly utilizes processes and threads, with both executing simultaneously and independently, but threads have the ability to share the memory of a single process.
Both parallel and serial can occur in tandem via the use of event loops in different threads working together.
The use of threaded programming is challenging, as you can run into trouble in situations where the same variables or registers in memory are being modified and used by multiple threads at the same time. While JS doesn't share data across threads, even simple things such as the sequence of threads can cause issues, or confusion at the least.

-Run-to-Completion-
JS is single-threaded, so functions run through to completion before running the next. This is known as "run-to-completion" behavior.
If viewed from the perspective of function/event-ordering level, a global chunk could be considered synchronous as it "happens now" and any function chunks (that aren't immediately invoked at the beginning of global (recall they aren't hoisted)) could be considered asynchronous as they "happen later". While there is still a degree of nondeterminism involved, this is more determinable than threads that introduce a variable level of statement and expression operation ordering.
Function-ordering nondeterminism when applied to the behavior of JS is referred to as "race condition", as multiple functions are "racing" to see which condition plays out, adding a degree of unreliability to the result.
Generators are functions that do not have your typical run-to-completion behavior.

-Concurrency-
When appending to a list of updates on a page upon scrolling down, you are executing at least two (virtual) procesess/tasks simultaneously (*roughly* at the same time, rather than instantaneously). The first is a response to the appropriate `onscroll` event firing, resulting in an Ajax request for more content. The second is to display the content once a response is received from the Ajax request.
Whether these operations occur in parallel or not, the simultaneous ***execution*** of multiple processes over the same period is regarded under the label of "concurrency". Consider it to be "process" or task-level parallelism, rather than operational/threaded.
With the previous example, it is possible that both an `onscroll`-triggering Ajax request is made and a response from an entirely different request is received and executed at roughly the same time. Keep in mind, though, that only one event can be executed in the JS engine at a time, so they must first be interleaved into the hosting environment's event queue and sequentially fed to the engine. The processes only run concurrently at task-level, with the events scheduled and executed in a one at a time, single-threaded manner.

-Noninteracting-
Nondeterminism is not an issue if these concurrently virtual processes/tasks you are interleaving into the event queue are unrelated and don't interact with each other.
If the concurrent processes will work as intended, regardless of its ordering, this would not be considered a race condition bug.

-Interaction-
Concurrent processes will interact more commonly than not. Always remedy race condition nondeterminism via value sharing in scopes by delineating different potential responses in your callbacks, checking that all necessary conditions are met/completed (especially those from other processes). You may also need to ensure you are carving out separate spaces for any response data to be stored (such as storing one specific type of response in one array slot, adding another to a different slot, etc), in order to maintain proper coordination of ordering interaction.
`if` statements that aren't ran until a `true` return of conditional checks for values that won't be set until the completion of callbacks are referred to as "gates".
A "latch" (sometimes called a "race"), is a nondeterministic concurrency interaction that is explicitly designed to only allow for callback execution of the first process to complete.

-Cooperation-
Cooperative concurrency is the act of taking longer processes and batching them out, allowing for room to interleave the operations of other processes into the event loop.
For example, if a resposne for one process is received that then runs a callback mapping several million values onto an array, everything else (other processes, UI updates, user events) will be unresponsive and unable to update. Instead, you can process such a large amount of results by breaking them up into smaller asynchronous batch operations that process after each one yields back to the event loop, effectively allowing other waiting events to occur before running the next batch, which results in a more performant site/app.
This can be done using the `setTimeout(.., 0)` hack, which is a simple way to have the timer asynchronously schedule the referenced function at the end of the event loop queue as soon as it can. Node.js uses a similar `process.nextTick(..)`.
As of the writing of the book, there is no single direct way to ensure the ordering of async events across all environments.
Cooperation can also be combined with concurrent interaction ordering techniques when necessary.

-Jobs-
The job queue, a new addition in ES6, is another layer added on top of the event loop queue that is mostly (indirectly) exposed via the use of Promises.
One way to conceptualize the job queue is that it exists at the end of every tick in the event loop queue. Some async actions arising during an event loop queue tick may not be added to the end of that queue, but rather to the job queue at the end of that tick as a job, intended to run immediately after that tick.
A job can result in the addition to more jobs at the end of the same job queue.
Jobs allow for somewhat more defined and guaranteed ordering. Similar to the `setTimeout(.., 0)` hack, but scheduled at the end of the current event tick, rather than at the end of the entire event queue loop.

-Statement Ordering-
Compiler statement reordering will never reorder or combine statements in a way that will create observable side effects, only performing safe optimizations.
Although altered statement ordering has no observable impact, it is best to remember that code is not always compiled to run in the top-down fashion in which it is written, instead being constantly restructured by the compiler to run in more of a concurrent and interacting fashion, not dissimilar from the flow of async code.

-Review-
JS code is broken into multiple chunks of code, the first of which runs "now", and the latter which runs "later" (as a response to an event). These chunks share scope and state.
User interaction, I/O, and timers can all add events to the event queue. Only one event from the queue can process at a time.
Concurrency is when multiple chains of events (known as processes or tasks) are woven together on the event loop, appearing to run simultaneously. 
Interaction coordination between concurrent processes is often required to guarantee precise ordering or prevent unwanted race conditions that could cause unpredictable results.
You can also break large processes into smaller chunks to allow cooperation and cohabitation with other various processes, I/O, and rendering that may be a part of the event queue as well.

===========================================Chapter 2===========================================
Callbacks

Callbacks are the most common and fundamental pattern of asynchrony that occur in JavaScript.

-Continuations-
Callback functions wrap or encapsulate the continuation of a program.

-Sequential Brain-
The human brain works similarly to the event loop queue via concurrent single-tasking.

-Doing Versus Planning-
While we think in step-by-step behaviors, callbacks are not expressed in such a (sequential) manner when moving to asynchrony.

-Nested/Chained Callbacks-
Nested callbacks are often referred to as "callback hell" or the "pyramid of doom", due to their confusing combination of nesting and lack of easily readable ordering when using async function calls.
Author points out that nesting really has little to do with the difficult readability, but moreso the unsequential nature of function execution when using async callbacks. This becomes even more confusing once you begin manually hardcoding alternate conditional paths, error handling forks, simultaneous callbacks, branches into parallel (concurrent) callbacks, etc.

-Trust Issues-
Callback-driven code and its lack of mirroring to the sequential brain are a part of confusing aspects of async, but inversion of control is a much deeper and ambiguous occurence.
Because you are usually handing off your callback functions to a third-party utility or a method you did not write or directly control, expectations for how/if a return is made may not always be clearly defined.

-Tale of Five Callbacks-
A lot of things can potentially go wrong with third-party API utilities that employ the use of async callbacks.
These include receiving multiple (unintended) callback responses for a single request, a lack of or late intended response, an early callback response, a lack of or incompatible return parameters passed to the callback, or disappearing errors/exceptions.
If you aren't positive that you can trust a utility to handle your async callbacks, you would have to add handle every single situation that could potentially go awry.

-Not Just Others' Code-
While the use of versioned APIs or self-hosted libraries can help remove much ambiguity and potential for mishap, you should still add checks and normalizations for your async code.
This introduces a lot of boilerplate or overhead code that needs to be repeated for each async callback.

-Trying to Save Callbacks-
Some APIs are designed to offer split callbacks for both success and failure conditions. This pattern is what the ES6 Promise API uses. 
Another callback pattern is the error-first or Node style. If successful, the first returned argument will be falsy or an empty object.
These designs still don't deal with that majority of the previously outlined trust issues that can occur. It also introduces the additional potential problem returns where you receive both error and success objects at once, or nothing at all for each argument. This means your boilerplate surrounding each callback is going to need to be even more verbose.
You can write a timeout function that cancels the event after the specified amount of time passes, pass your callback into that as an argument (to be executed), and then pass that function into your async call in place of the callback function.
In scenarios where it is possible that a callback could be invoked synchronously (such as with a pre-cached url), it is always best to still add it to the event loop to be asynchronously returned later, as not doing so can introduce unpredictability and bugs in places there is still remaining code to be executed. The order of execution would essentially become dependent upon the synch/asynchronicity of the callback.
You can convert a potentially synchronous callback to an async one by passing it to a utility function that checks if a `setTimeout(..)` of 0 (adds to end of event loop) has completed. If it completes first, it just passes the callback function as is. If not, the returned callback that was passed into the utility will return once the `setTimeout(..)` interval has completed (essentially completing at least one asynch tick).

===========================================Chapter 3===========================================
Promises

The idea of Promises is that, rather than inverting control of the continuation of your program over to a third party in hopes that it will correctly invoke your callback, you expect a return letting you know when that third party API has finished its task so that your code can then decide what to do next.
Most new async APIs are being designed to make use of Promises.
"Immediately", in regards to Promises, is usually used when referring to Job queue behavior, rather than the synchronous "now".
