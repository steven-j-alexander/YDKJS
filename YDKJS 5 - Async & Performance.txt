===========================================Chapter 1===========================================
Asynchrony: Now & Later

-A Program In Chunks-
A JS program consists of several chunks, with some chunks running in the "present", and the rest running "later". A common type of a chunk unit is a function.
Asynchronous tasks do not block until completion, whereas synchronous tasks do. Ajax requests complete asynchronously. Requests are made in the present and the results are returned later.
The simplest way to block and wait from now until later when a return is recieved is to use a callback function.
While it is possible to make Ajax requests synchronously, it locks the browser UI, preventing user interaction. It is best avoided.
"Later" (asynchronous) code chunks are often functions that are set to run as a response to specific circumstances (timer or click event, Ajax response, etc).

-Async Console-
Until ES6, all asynchrony in JS was actually handled by the hosting environment. The JS engine would merely run the code chunk it was given. Hosting environments themselves were engineered to handle multiple chunks of JS code (and return their values), executing them over time, in accordance with their internal event loop. This means the surrounding environment is what has traditionally handled all event scheduling.
When making an Ajax request to fetch data from a server, you would set up a response code in a function (referred to as a "callback"). The JS engine suspends the execution and sends instruction to the hosting environment to suspend execution of the response function until completion of the network request, essentially requesting it "call" the function "back" once it retrieves (or fails to retrieve) the appropriate data. The browser itself listens for a response from the network, then schedules the execution of the callback function by inserting it into its event loop.
Each iteration of this callback event loop is called a "tick". During each tick, the loop checks if an event is waiting on the queue. If so, it is removed from the queue and the chunk is executed by running the function callback within the JS engine.
`setTimeout(..)` doesn't directly put your callback on the event loop queue. It sets a timer that, once expired, places the provided callback into the event loop for a future tick of the loop to execute. Even events not a part of your program can be added onto the hosting environment's queue loop as well. This is why the functions you pass it don't always fire with perfect accuracy.
As of ES6, the loop queue is now within scope of the JS engine in addition to the standard hosting environment accessibility/management. The primary reason for widening the breadth of control is for the usage of ES6's Promises, which require direct and specific control over event scheduling.

-Parallel Threading-
While async refers to the gap between now and later (scheduled and ran in serial), parallelism is about simultaneous execution.
Parallel computing commonly utilizes processes and threads, with both executing simultaneously and independently, but threads have the ability to share the memory of a single process.
Both parallel and serial can occur in tandem via the use of event loops in different threads working together.
The use of threaded programming is challenging, as you can run into trouble in situations where the same variables or registers in memory are being modified and used by multiple threads at the same time. While JS doesn't share data across threads, even simple things such as the sequence of threads can cause issues, or confusion at the least.

-Run-to-Completion-
JS is single-threaded, so functions run through to completion before running the next. This is known as "run-to-completion" behavior.
If viewed from the perspective of function/event-ordering level, a global chunk could be considered synchronous as it "happens now" and any function chunks (that aren't immediately invoked at the beginning of global (recall they aren't hoisted)) could be considered asynchronous as they "happen later". While there is still a degree of nondeterminism involved, this is more determinable than threads that introduce a variable level of statement and expression operation ordering.
Function-ordering nondeterminism when applied to the behavior of JS is referred to as "race condition", as multiple functions are "racing" to see which condition plays out, adding a degree of unreliability to the result.
Generators are functions that do not have your typical run-to-completion behavior.

-Concurrency-
When appending to a list of updates on a page upon scrolling down, you are executing at least two (virtual) procesess/tasks simultaneously (*roughly* at the same time, rather than instantaneously). The first is a response to the appropriate `onscroll` event firing, resulting in an Ajax request for more content. The second is to display the content once a response is received from the Ajax request.
Whether these operations occur in parallel or not, the simultaneous ***execution*** of multiple processes over the same period is regarded under the label of "concurrency". Consider it to be "process" or task-level parallelism, rather than operational/threaded.
With the previous example, it is possible that both an `onscroll`-triggering Ajax request is made and a response from an entirely different request is received and executed at roughly the same time. Keep in mind, though, that only one event can be executed in the JS engine at a time, so they must first be interleaved into the hosting environment's event queue and sequentially fed to the engine. The processes only run concurrently at task-level, with the events scheduled and executed in a one at a time, single-threaded manner.

-Noninteracting-
Nondeterminism is not an issue if these concurrently virtual processes/tasks you are interleaving into the event queue are unrelated and don't interact with each other.
If the concurrent processes will work as intended, regardless of its ordering, this would not be considered a race condition bug.

-Interaction-
Concurrent processes will interact more commonly than not. Always remedy race condition nondeterminism via value sharing in scopes by delineating different potential responses in your callbacks, checking that all necessary conditions are met/completed (especially those from other processes). You may also need to ensure you are carving out separate spaces for any response data to be stored (such as storing one specific type of response in one array slot, adding another to a different slot, etc), in order to maintain proper coordination of ordering interaction.
`if` statements that aren't ran until a `true` return of conditional checks for values that won't be set until the completion of callbacks are referred to as "gates".
A "latch" (sometimes called a "race"), is a nondeterministic concurrency interaction that is explicitly designed to only allow for callback execution of the first process to complete.

-Cooperation-
Cooperative concurrency is the act of taking longer processes and batching them out, allowing for room to interleave the operations of other processes into the event loop.
For example, if a resposne for one process is received that then runs a callback mapping several million values onto an array, everything else (other processes, UI updates, user events) will be unresponsive and unable to update. Instead, you can process such a large amount of results by breaking them up into smaller asynchronous batch operations that process after each one yields back to the event loop, effectively allowing other waiting events to occur before running the next batch, which results in a more performant site/app.
This can be done using the `setTimeout(.., 0)` hack, which is a simple way to have the timer asynchronously schedule the referenced function at the end of the event loop queue as soon as it can. Node.js uses a similar `process.nextTick(..)`.
As of the writing of the book, there is no single direct way to ensure the ordering of async events across all environments.
Cooperation can also be combined with concurrent interaction ordering techniques when necessary.

-Jobs-
The job queue, a new addition in ES6, is another layer added on top of the event loop queue that is mostly (indirectly) exposed via the use of Promises.
One way to conceptualize the job queue is that it exists at the end of every tick in the event loop queue. Some async actions arising during an event loop queue tick may not be added to the end of that queue, but rather to the job queue at the end of that tick as a job, intended to run immediately after that tick.
A job can result in the addition to more jobs at the end of the same job queue.
Jobs allow for somewhat more defined and guaranteed ordering. Similar to the `setTimeout(.., 0)` hack, but scheduled at the end of the current event tick, rather than at the end of the entire event queue loop.

-Statement Ordering-
Compiler statement reordering will never reorder or combine statements in a way that will create observable side effects, only performing safe optimizations.
Although altered statement ordering has no observable impact, it is best to remember that code is not always compiled to run in the top-down fashion in which it is written, instead being constantly restructured by the compiler to run in more of a concurrent and interacting fashion, not dissimilar from the flow of async code.

-Review-
JS code is broken into multiple chunks of code, the first of which runs "now", and the latter which runs "later" (as a response to an event). These chunks share scope and state.
User interaction, I/O, and timers can all add events to the event queue. Only one event from the queue can process at a time.
Concurrency is when multiple chains of events (known as processes or tasks) are woven together on the event loop, appearing to run simultaneously. 
Interaction coordination between concurrent processes is often required to guarantee precise ordering or prevent unwanted race conditions that could cause unpredictable results.
You can also break large processes into smaller chunks to allow cooperation and cohabitation with other various processes, I/O, and rendering that may be a part of the event queue as well.

===========================================Chapter 2===========================================
Callbacks

Callbacks are the most common and fundamental pattern of asynchrony that occur in JavaScript.

-Continuations-
Callback functions wrap or encapsulate the continuation of a program.

-Sequential Brain-
The human brain works similarly to the event loop queue via concurrent single-tasking.

-Doing Versus Planning-
While we think in step-by-step behaviors, callbacks are not expressed in such a (sequential) manner when moving to asynchrony.

-Nested/Chained Callbacks-
Nested callbacks are often referred to as "callback hell" or the "pyramid of doom", due to their confusing combination of nesting and lack of easily readable ordering when using async function calls.
Author points out that nesting really has little to do with the difficult readability, but moreso the unsequential nature of function execution when using async callbacks. This becomes even more confusing once you begin manually hardcoding alternate conditional paths, error handling forks, simultaneous callbacks, branches into parallel (concurrent) callbacks, etc.

-Trust Issues-
Callback-driven code and its lack of mirroring to the sequential brain are a part of confusing aspects of async, but inversion of control is a much deeper and ambiguous occurence.
Because you are usually handing off your callback functions to a third-party utility or a method you did not write or directly control, expectations for how/if a return is made may not always be clearly defined.

-Tale of Five Callbacks-
A lot of things can potentially go wrong with third-party API utilities that employ the use of async callbacks.
These include receiving multiple (unintended) callback responses for a single request, a lack of or late intended response, an early callback response, a lack of or incompatible return parameters passed to the callback, or disappearing errors/exceptions.
If you aren't positive that you can trust a utility to handle your async callbacks, you would have to add handle every single situation that could potentially go awry.

-Not Just Others' Code-
While the use of versioned APIs or self-hosted libraries can help remove much ambiguity and potential for mishap, you should still add checks and normalizations for your async code.
This introduces a lot of boilerplate or overhead code that needs to be repeated for each async callback.

-Trying to Save Callbacks-
Some APIs are designed to offer split callbacks for both success and failure conditions. This pattern is what the ES6 Promise API uses. 
Another callback pattern is the error-first or Node style. If successful, the first returned argument will be falsy or an empty object.
These designs still don't deal with that majority of the previously outlined trust issues that can occur. It also introduces the additional potential problem returns where you receive both error and success objects at once, or nothing at all for each argument. This means your boilerplate surrounding each callback is going to need to be even more verbose.
You can write a timeout function that cancels the event after the specified amount of time passes, pass your callback into that as an argument (to be executed), and then pass that function into your async call in place of the callback function.
In scenarios where it is possible that a callback could be invoked synchronously (such as with a pre-cached url), it is always best to still add it to the event loop to be asynchronously returned later, as not doing so can introduce unpredictability and bugs in places there is still remaining code to be executed. The order of execution would essentially become dependent upon the synch/asynchronicity of the callback.
You can convert a potentially synchronous callback to an async one by passing it to a utility function that checks if a `setTimeout(..)` of 0 (adds to end of event loop) has completed. If it completes first, it just passes the callback function as is. If not, the returned callback that was passed into the utility will return once the `setTimeout(..)` interval has completed (essentially completing at least one asynch tick).

===========================================Chapter 3===========================================
Promises

The idea of Promises is that, rather than inverting control of the continuation of your program over to a third party in hopes that it will correctly invoke your callback, you expect a return letting you know when that third party API has finished its task so that your code can then decide what to do next.
Most new async APIs are being designed to make use of Promises.
"Immediately", in regards to Promises, is usually used when referring to Job queue behavior, rather than the synchronous "now".

-What Is a Promise?: Future Value-
One way to think of a Promise is as a receipt for a future value which you have no yet received. It represents a time-independent future value.
Once the future value is ready, you exchange the value promise for it. You may also receive an indication that no value will be availed, in the form of a failure.
Lastly, you may be left with an unresolved state where the future value is never retrieved.

-Values Now and Later-
When working with callbacks, you know they won't be invoked until request results are later returned. But what if you are performing an operation that relies upon one or more returned callback values?
To consistently handle operands that may be either "now" or "later", you must make the entire operation async, either by manually checking/waiting for values to resolve, or some other mechanism.

-Promise Value-
Promises return values in the temporal, time-independent manner that is required when performing operations of uncertain synchronicity.
Promises can be created that resolve once an array of other promises have been successfully returned (by creating the promise with `Promise.all(..)`).
Chaining another call to it using the `.then(..)` call creates another promise. In its return, you can invoke a function that can be passed any return values from your initial promise invocation.
Promise rejection values, commonly referred to as "rejection reasons", can be set directly in the program or implicitly resulted via runtime error.
An error handler function can be directly added to a `.then` chained-call by adding it as the second parameter.
As Promises encapsulate time-dependent state, they can be used in a manner that is predictable and time-independent. Its return value becomes immutable and observable once resolved.

-Completion Event-
While one Promise can be equivalent to a future value, they can also function as a flow control mechanism within the scope of a larger sequence of asynchronous operations.
Classically, such situations call for listeners and events, so you can view this from the perspective of needing to listen for a completion or continuation event to be emitted by a particular function.
The term "completion event" is more related to the importance of the execution of a function finishing, compared to "continuation event", where the focus is more about being able to continue with the following steps in a sequence.
With Promises, you are essentially setting up two listeners, one for a success event and one for a failure event to be returned. You are only awaiting the final outcome of the event call. This contrasts callbacks, where the "notification" would be the execution of the callback function itself.
This means that Promises essentially separate the called function from the calling code's subscription to the completion/continuation events, with the called function's returned event being ran against the two event handlers. This uninverts the control previously inverted by callbacks.
With this level of separation of concerns, you can give multiple separate parts/functions in your code the capability to independently listen for return events from the same function.
The event object returned is basically a neutral third-party negotiation between separate, independent task entities.

-Promise "Events"-
Promise "events" don't strictly follow the format previously outlined, although they certainly behave in such a manner for these purposes. You use `.then(..)` to register a "then" event (either "fulfillment" or "rejection"), although you do not explicitly see them in code.
`new Promise( function(..){ .. } )` is generally referred to as a "revealing constructor". In it, the function passed in is executed immediately, rather than async deferred like with `.this(..)`. The function is provided with both a `resolve` and `reject` parameter, which are resolution functions for the Promise that signal success or failure.
Your resolution handler functions wait for completion of the Promise resolution function before flow control takes place (using `.then(..)`), which doesn't always necessitate a message being sent to it, as mere completion is sometimes the only thing to be required for continuation.
Chaining `then(..)`s results in a different pattern known as forking, versus semi-colon separated `then(..)` statements that results in a splitting behavior.
You can also use the promise itself in combination with `.then(..)` to control the execution of functions, the difference being that an explicit call of these handler functions means that they will always run, which may necessitate the need for error handling being included in the function, whereas `then(..)` allows you to directly specify an error handler as the second parameter.

-Thenable Duck Typing-
You can receive Promises from another window/iframe, which means that checking for an `instanceof` a Promise would result in a failure to identify. Some libraries/frameworks also use their own form of Promises that are unrelated to the built-in ES6 type.
The way to recognize a Promise or something conformant and Promise-like is by checking if it is "thenable", which is any object with a `then(..)` method on it.
Type checking that identifies based on the shape (properties that are present) of an object is referred to as "duck typing" ("looks like a duck, quacks like a duck, must be a duck").
Duck typing Promises can be problematic in situations that have the matching property name, but weren't intended to be treated as thenable Promises, or objects that inherit "then(..)" from their `[[Prototype]]`, that are also unintentionally recognized as Promises. Another circumstance (which is already a no-no as you shouldn't be adding properties to JS native prototypes) is the existence of an added `then(..)` property on the Array or Object prototypes, which would result in all arrays/objects being thenable. Several pre-ES6 non-Promise libraries exist that possess `then(..)` methods.
Regardless of the poor standard chosen for identifying Promises, duck typing are still said to be helpful when caution is taken.

-Promise Trust-
Promises are designed to resolve all inversion of control issues outlined with the use of callbacks in the previous chapter.

-Calling Too Early-
Promises, by definition, cannot be subjected to race conditions. Even immediately fulfilled Promises are only capable of being ***observed*** asynchronously, as callbacks provided to `then(..)` cannot be called synchronously.

-Calling Too Late-
A Promise's `then(..)` observation callbacks are automatically scheduled (in order) upon the calling of `resolve(..)` or `reject(..)` by the Promise. They will be predictably fired at the end of the current asynchronous "tick" as Jobs. These registered callbacks cannot affect the calling of any the proceeding `then(..)` callbacks.
This means that embedding `then(..)` callbacks inside of other callbacks will still result in all `then(..)` callbacks from the enclosing scope being scheduled first, in sequence.

-Promise Scheduling Quirks-
There are some nuances where `then(..)` returns don't appear be properly sequenced.
One example is when creating a Promise that awaits the resolution of another Promise in the same enclosing scope before its own resolution. Since you are essentially "unwrapping" another Promise asynchronously (you have to wait for the enclosed value to resolve), the "wrapper" Promise is added to the end of the asynchronous Job queue, after any remaining callbacks have completed (including the remainder in the same enclosed scope).
Because of such nuances, it is best to code in a way that the ordering or scheduling of multiple Promise callbacks are depended upon.

-Never Calling the Callback-
Nothing, including JS errors, can prevent a Promise from returning its resolution, as long as fulfillment/rejection callbacks are registered. Even callback errors themselves don't get swallowed, and the callback is still always ran.
Promises themselves possess a "race" method that provides a means to return a rejection callback (with an error specifying the reason) when a call doesn't asynchronously resolve in the specified time. This means, you do not need to worry about a Promise ever causing your program to hang indefinitely.

-Calling Too Few or Too Many Times-
Too few is best defined as not calling at all, as the correct amount of times for a callback to be called is once.
Promises are defined to only be resolved once, with that resolution value being treated as immutable. All subsequent attempts are silently ignored. This also means that any `then(..)` registered callbacks will be called a single time as well (for each time it exists in your code).

-Failing to Pass Along Any Parameters/Environment-
If the return value for a Promise is not explicitly returned, it will be `undefined` and still be passed to all registered callbacks.
All parameters beyond the first that are passed in `resolve(..)` or `reject(..)` will be silently ignored. This is because the use of multiple parameters in a resolution value are not valid usage of the Promise mechanism. You must wrap multiple values in a single `array` or `object`. Similar behavior applies to invalid actions such as calling `resolve(..)` more than once.
Just like JS functions, Promise callbacks retain access to the enclosing scope in which they are defined.

-Swallowing Any Errors/Exceptions-
Rejection reason values are passed to rejection callbacks.
`TypeError`s and `ReferenceError`s that occur during the creation or observation of a Promise will be returned in its `rejection(..)` value in the form of a catchable error object.
This behavior has the additional benefit of rendering errors within Promises as asynchronous occurences, allowing for the continued maintenance of sequential predictability.
Recall that `then(..)` calls return another Promise, so if your error only occurs during observation, it's that new Promise that will be rejected. It cannot use its own handler to call a rejection because that is specifically for the Promise that it is observing (which in this example, was fulfilled with a non-rejection return value), and Promises are immutable once resolved.

-Trustable Promise?-
Promises don't get rid of callbacks, but rather change them from being passed to a function to be executed upon receiving a return response, to receiving something back from a function return (such as a genuine Promise) and then passing the callback to that.
To ensure the trustability of whatever you receive back from your function return is a genuine Promise, you can use the `Promise.resolve(..)` utility.
Passing an immediate, non-Promise value to `Promise.resolve(..)` will return a genuine promise that is fulfilled with that value.
Passing a genuine, thenable Promise value to `Promise.resolve(..)` returns the same promise back.
Passing a non-Promise, but thenable value to `Promise.resolve(..)` will result in the utility attempting to unwrap the value continually until a final, non-Promise-like value results, and then return a genuine promise that is fulfilled with that value.
This helps for filtering untrustworthy and potentially thenable non-Promise values, unwrapping them if need be, and returning them wrapped in a normalized and trustworthy Promise to be asynchronously chained/observed off of.

-Trust Built-
Promises are a pattern that augments that already-established use of callbacks with trustable semantics that allow for more reasonable and reliable behavior.
They effectively uninvert the inversion of control caused by callback usage, and place it into a trustable system designed specifically for the readability, robustness, and maintainability of asynchronous code.

-Chain Flow-
You can create an intermediate variable for each fulfilled value in a chain and call that variable with `then(..)`, or just chain your `then(..)` promises together to have the each promise's return value passed to its proceeding and automatically-created promise.
Just as `Promise.resolve(..)` automatically unwraps recursively to get to the final value of a thenable, the same behavior occurs when returning a thenable or Promise from either a fulfillment or rejection handler. This means that you can return a new Promise from a chained `.then(..)` Promise, and the subsequently-chained `.then(..)` will call its function once the Promise it was passed asynchronously completes and returns an unwrapped value. Using this, you can construct sequences containing as many asynchronous steps as needed.
Return values are not necessary when `then(..)`-chaining, as `undefined` will still be returned without an explicit `return` statement. The Promise resolution itself is the signal to proceed to the following step in the chain.
The Promise mechanism automatically combines the states of both a returned Promise and the Promise that is returning it, so you can think of the returned Promise as a replacement for the previously-returned chained Promise that enclosed the return.
One practical example of chaining Promises in this manner is to make an ajax request async-aware by returning a Promise, and use it to construct a URL using a response from an initial http request using the `request(..)` method, which would return a Promise containing a response message to be used in the subsequent URL construction. You'd follow that step in the async flow control chain up with a final step that waits for the second ajax call to complete. This acts as both a flow control and pushes relevant response messages to subsequent links in the chain with each step.
When an error is encountered in one of the steps of an async sequence, it will return a `rejection(..)` function, that can be handled by the subsequent step, whose handler can even return a fulfillment from the promise for the next step to receive, if it's set up that way, putting the chain back into a state of fulfillment.
If a `then(..)` only contains a fulfillment error, a rejection handler will be substituted in that will rethrow the same error that was passed to it, effectively propagating the error along each step in the chain until an explicit error handler is discovered.
There is also a default fulfillment handler that is substituted into a `then(..)` step when a valid function is not passed in. It simply passes the received value along to the next step. A shortcut for this pattern is to use `catch(function(err){..})`.
If a fulfillment/rejection returns a Promise of its own, it is unwrapped and its resolution is then substituted in as the resolution for the chained Promise returned from the current `then(..)` in the chain.
A much better pattern for expressing sequential flow control in such a manner is via the use of generators.

-Terminology: Resolve, Fulfill, and Reject-
There is some confusion with the name of the first callback parameter of the `Promise(..)` constructor being "resolve", since resolution implies either fulfillment or rejection.
The `.resolve(..)` Promise API method will actually create a Promise that is resolved to the value passed to it, including non-Promise, non-thenable, and thenable values. These may actually resolve to rejected Promise values, in the case where it is passed a `Promise.reject(..)` value (which it then unwraps and passes as a rejected Promise).
This means that the first parameter in a Promise callback (in addition to unwrapping a genuine Promise) can also unwrap thenable values to reveal a rejected state, return a Promise with that same state.
`reject(..)` does not perform this same thenable unwrapping behavior. When passing such a value, that still-wrapped value will serve as the reason for the rejection. A rejection handler that followed would recieve that still-wrapped value.
The author suggests calling the callbacks provided to your subsequently-chained `.then(..)`s as `fulfilled(..)` and `rejected(..)`, as the first parameter passed to this method is unambiguously and always a fulfillment case, unlike with `Promise(..)` constructors. ES6 spec uses `onFulfilled(..)` and `onRejection(..)`, similarly.
