===========================================Chapter 1===========================================
Asynchrony: Now & Later

-A Program In Chunks-
A JS program consists of several chunks, with some chunks running in the "present", and the rest running "later". A common type of a chunk unit is a function.
Asynchronous tasks do not block until completion, whereas synchronous tasks do. Ajax requests complete asynchronously. Requests are made in the present and the results are returned later.
The simplest way to block and wait from now until later when a return is recieved is to use a callback function.
While it is possible to make Ajax requests synchronously, it locks the browser UI, preventing user interaction. It is best avoided.
"Later" (asynchronous) code chunks are often functions that are set to run as a response to specific circumstances (timer or click event, Ajax response, etc).

-Async Console-
Until ES6, all asynchrony in JS was actually handled by the hosting environment. The JS engine would merely run the code chunk it was given. Hosting environments themselves were engineered to handle multiple chunks of JS code (and return their values), executing them over time, in accordance with their internal event loop. This means the surrounding environment is what has traditionally handled all event scheduling.
When making an Ajax request to fetch data from a server, you would set up a response code in a function (referred to as a "callback"). The JS engine suspends the execution and sends instruction to the hosting environment to suspend execution of the response function until completion of the network request, essentially requesting it "call" the function "back" once it retrieves (or fails to retrieve) the appropriate data. The browser itself listens for a response from the network, then schedules the execution of the callback function by inserting it into its event loop.
Each iteration of this callback event loop is called a "tick". During each tick, the loop checks if an event is waiting on the queue. If so, it is removed from the queue and the chunk is executed by running the function callback within the JS engine.
`setTimeout(..)` doesn't directly put your callback on the event loop queue. It sets a timer that, once expired, places the provided callback into the event loop for a future tick of the loop to execute. Even events not a part of your program can be added onto the hosting environment's queue loop as well. This is why the functions you pass it don't always fire with perfect accuracy.
As of ES6, the loop queue is now within scope of the JS engine in addition to the standard hosting environment accessibility/management. The primary reason for widening the breadth of control is for the usage of ES6's Promises, which require direct and specific control over event scheduling.
