===========================================Chapter 1===========================================
Asynchrony: Now & Later

-A Program In Chunks-
A JS program consists of several chunks, with some chunks running in the "present", and the rest running "later". A common type of a chunk unit is a function.
Asynchronous tasks do not block until completion, whereas synchronous tasks do. Ajax requests complete asynchronously. Requests are made in the present and the results are returned later.
The simplest way to block and wait from now until later when a return is recieved is to use a callback function.
While it is possible to make Ajax requests synchronously, it locks the browser UI, preventing user interaction. It is best avoided.
"Later" (asynchronous) code chunks are often functions that are set to run as a response to specific circumstances (timer or click event, Ajax response, etc).

-Async Console-
Until ES6, all asynchrony in JS was actually handled by the hosting environment. The JS engine would merely run the code chunk it was given. Hosting environments themselves were engineered to handle multiple chunks of JS code (and return their values), executing them over time, in accordance with their internal event loop. This means the surrounding environment is what has traditionally handled all event scheduling.
When making an Ajax request to fetch data from a server, you would set up a response code in a function (referred to as a "callback"). The JS engine suspends the execution and sends instruction to the hosting environment to suspend execution of the response function until completion of the network request, essentially requesting it "call" the function "back" once it retrieves (or fails to retrieve) the appropriate data. The browser itself listens for a response from the network, then schedules the execution of the callback function by inserting it into its event loop.
Each iteration of this callback event loop is called a "tick". During each tick, the loop checks if an event is waiting on the queue. If so, it is removed from the queue and the chunk is executed by running the function callback within the JS engine.
`setTimeout(..)` doesn't directly put your callback on the event loop queue. It sets a timer that, once expired, places the provided callback into the event loop for a future tick of the loop to execute. Even events not a part of your program can be added onto the hosting environment's queue loop as well. This is why the functions you pass it don't always fire with perfect accuracy.
As of ES6, the loop queue is now within scope of the JS engine in addition to the standard hosting environment accessibility/management. The primary reason for widening the breadth of control is for the usage of ES6's Promises, which require direct and specific control over event scheduling.

-Parallel Threading-
While async refers to the gap between now and later (scheduled and ran in serial), parallelism is about simultaneous execution.
Parallel computing commonly utilizes processes and threads, with both executing simultaneously and independently, but threads have the ability to share the memory of a single process.
Both parallel and serial can occur in tandem via the use of event loops in different threads working together.
The use of threaded programming is challenging, as you can run into trouble in situations where the same variables or registers in memory are being modified and used by multiple threads at the same time. While JS doesn't share data across threads, even simple things such as the sequence of threads can cause issues, or confusion at the least.

-Run-to-Completion-
JS is single-threaded, so functions run through to completion before running the next. This is known as "run-to-completion" behavior.
If viewed from the perspective of function/event-ordering level, a global chunk could be considered synchronous as it "happens now" and any function chunks (that aren't immediately invoked at the beginning of global (recall they aren't hoisted)) could be considered asynchronous as they "happen later". While there is still a degree of nondeterminism involved, this is more determinable than threads that introduce a variable level of statement and expression operation ordering.
Function-ordering nondeterminism when applied to the behavior of JS is referred to as "race condition", as multiple functions are "racing" to see which condition plays out, adding a degree of unreliability to the result.
Generators are functions that do not have your typical run-to-completion behavior.
