===========================================Chapter 1===========================================
'this' Or That?

-Why this?-
The 'this' keyword allows functions to be reused against multi-context objects, instead of needing a separate function for each object.
The 'this' mechanism provides an elegant way to implicitly pass an object reference, which leads to cleaner and more reusable API design. Passing along parameters in increasingly complex usage patterns becomes cumbersome and messier than simply passing things through the 'this' context.

-Confusions: Itself-
'this' does not refer to or root in the enclosing function itself.
You can add a property to a function but using 'this' to access a property of the same name will not necessarily refer to that function object.
Devs who fail to understand the 'this' keyword often fall back onto lexical scope at this point and just create a new object.
If you need to access a function's object, you can use a named function and refer to it using its identifier.
Do not use anonymous functions if they will be referring to themselves. There is an arguments.callee reference that was used in anonymous functions, but it is now deprecated. Use a named function expression instead.
To use 'this' in such a situation, you would force 'this' to point to the function object using the call() method on the function, which executes the function while allowing you to provide a value to 'this' (in this case, the function you want to refer to).

-Confusions: Its Scope-
'this' does not in any way refer to a functions lexical scope. While internally, scope is sort of like an object with properties of each available identifier, this is only accessible to the JS engine itself, and not the code.
You cannot bridge two scopes together by invoking one from the other leading with the 'this' keyword.

-What's this?-
'this' is a run-time binding, rather than an author-time binding. It has everything to do with how a function is called.
When you invoke a function, an activation record (or execution context) is created. It contains info on where the function was called from (the call-stack), how it was invoked, what parameters were passed, etc. One of the properties of this record is the 'this' reference that will be used for the duration of that function's execution.
Finding a function's call-site will determine how its execution will bind 'this'.

===========================================Chapter 2===========================================
'this' All Makes Sense Now!

-Call-site-
The call-stack is essentially the chain of functions called in order to get to whatever location your code is currently at in execution.
The call-site is the location (function or global) in which the function you have currently stepped into was invoked.
You can use a JS debugger in your browser by setting a breakpoint at the beginning of a function or insert a 'debugger;' statement in the same location to cause the debugger to pause and show you the call-site/stack for each invocation of that function when the code is executed.

-Nothing But Rules: Default Binding-
Variables declared in global scope are synonymous with global-object properties of the same name.
The default binding applies to the function call, so if the function was called from global, then 'this' would point to the global object.
When a function is called with a plain, undecorated function reference, default binding is the only type that would apply.
In strict mode, the global object is not eligible for default binding. 'this' would be set to undefined in a function with a global call-site. This would only apply if your function contents were set to strict mode. The state of the call-site is irrelevant.
Author opines that you should not mix non-strict with strict mode, although sometimes this is unavoidable due to the inclusion of third-party libraries.

-Implicit Binding-
If the call-site has a context object (an object reference precedes the function call), you could say the context 'owns' or 'contains' the function reference at the time the function is called.
The implicit binding rule demands that the context object is what should be used for the function call's 'this' binding.
'this.a' would be synonymous with 'obj.a'
Only the last or top level of the object reference property chain matters to the call-site when determining what should be used for the 'this' binding.

-Implicitly Lost-
If you create a new reference to the previous function call that is preceded by an object reference and then call that reference in a plain, undecorated fashion, default binding rules will apply. This is because the new reference is really just another reference to the function call itself. The call-site is what matters, so if it's simply a global, undecorated function call, you would have a value of global or undefined bound to that function's 'this' value, depending on your strict mode settings.
The same rule applies when passing a callback function. The preceding object reference in the passed function is essentially stripped out. Parameter passing is just an implicit assignment, so passing a function is an implicit reference assignment.
Another way 'this' can be of surprise is when functions you've passed your callback to intentionally change the 'this' reference for the call. Event handlers in popular JS libraries will frequently force your callback to have a 'this' which points to something such as the DOM element that triggered the event.

-Explicit Binding-
Explicit binding allows you to force a function call to use a specific object for the 'this' binding without putting a property reference on the object, like you would do with implicit binding.
The vast majority of functions have some utilities made available to them via their [[Prototype]] that can be useful for this, specifically the call(..) and apply(..) methods. Both of these methods take an object to use for 'this' as their first parameter, and then invoke it using the specified 'this'. This is an example of explicit binding.
If you pass a primitive value of type 'string', 'boolean', or 'number' as the 'this' binding, the primitive value is wrapped in its object form (new String(..), new Boolean(..), etc). This is commonly referred to as "boxing".
'call' and 'apply' are identical in respect to 'this' binding, although they do behave differently with their additional parameters.

-Hard Binding-
Explicit binding alone does not address the previous issue of a function losing its intended 'this' binding, being superceded by a framework, etc, but the hard binding variation of explicit binding does take care of this.
To hard bind, you create a function that forcibly invokes your target function using the call(..) or apply(..) method, explicitly binding its 'this' keyword to the object you specify. No matter how you later invoke the containing function, it will always manually invoke your target function with the object you specified bound to 'this'. This is called hard binding, which is both explicit and robust.
The most common way to wrap a function with a hard binding is to use the apply method to create a pass-thru of any received value: (apply( obj, arguments ))
Another way to express the hard binding pattern is to create a re-usable helper. This helper function would take both the function to be bound and the object to bind as parameters and would return a function that would bind them together and pass any additional arguments provided using the apply method. You'd then assign this bind function to a var and pass any of your additional arguments when you call that function.
This feature is actually a built-in method in ES5 as bind(..), which returns a new function that is hard-coded to call the original function using whatever object parameter you passed as the 'this' context.
In ES6, any function produced by the bind(..) method should have a .name property that provides you the original target function. For example, `bar = foo.bind` would result in bar.name giving a value of "bound foo".

-API Call "Contexts"-
Many library functions and new built-in JS functions provide a parameter, usually called "context", that is designed as a work-around to using bind(..).
Internally, these functions most likely use call(..) or apply(..) to explicitly bind behind the scenes to ensure a callback function uses a specified 'this'.

-'new' Binding-
The code pattern to use the 'new' operator in JS looks pretty much identical to the way it would be used in a class-oriented language, which would call the constructor for a newly instantiated class. However, JS does not have any connection to class-oriented functionality when using 'new'.
In JS, a constructor is basically just a function that is called with a 'new' operator in front of it. They are not attached to nor do they instantiate a class. They are regular functions that are hijacked by the use of 'new' in their invocation.
Pretty much any function, including built-in ones such as Number(..) can be called with 'new' in front of it, and that makes the function call a constructor call. There is no such thing as a constructor function, only a constructor call of a function.
When you invoke a function with new in front of it, also known as invoking a constructor call: 
	1. A brand new object is created (constructed), initialized by the function you called. 
	2. The newly-constructed object is [[Prototype]]-linked. 
	3. The newly-constructed object is set as the 'this' binding for that function call. 
	4. Unless the function returns its own alternate object, the 'new'-invoked function call will automatically return the newly-constructed object.
'new' is the final way that a function's 'this' can be bound, hence the name of 'new' binding'.

-Everything In Order-
When dealing with a situation where multiple rules are applied, default binding is the lowest-priority rule of the four bindings.
Explicit binding always takes precedence over implicit binding.
'new' binding is more precedent than implicit binding.
'new' and call/apply cannot be used together, but you can use hard binding to (less directly) test explicit binding against 'new' binding.
Recall that hard binding uses Function.prototype.bind(..) to create a new wrapper function that eschews its own 'this' binding in exchange for one that is manually provided.
The prototype bind(..) function has code built into it that gives 'new' binding more precedence over explicit binding. This is useful because you can still use the capability of bind(..) to pass arguments after the first 'this'-binding argument that will then be defaulted as standard arguments to the underlying function, while ignoring the 'this' hard-binding. This technique is called "partial application", which is a subset of "currying".

-Determining 'this'-
1. Is the function called with the 'new'? If so, 'this' is the newly constructed object (new binding).
2. Is the function called with the 'call' or 'apply' methods, or hidden inside a 'bind' hard binding? If so, 'this' is an explicitly specified object (explicit binding).
3. Is the function called with a context, otherwise known as an owning or containing (or preceding) object? If so, 'this' is that context object (implicit binding).
4. Otherwise, default the 'this'. If in strict mode, it will be undefined. If in non-strict mode, 'this' will be the global object.

-Binding Exceptions: Ignored 'this'-
There are some exceptions to the above rules that will result with the default binding rule being applied unexpectedly.
If you pass null or undefined as a 'this' binding parameter to the call/apply/bind methods, those values will be ignored and default binding rules will apply. This is sometimes used as the apply method is commonly used to spread out arrays of values as parameters to a function call. bind(..) can also curry out values as parameters in a similar fashion. 'null' works as a placeholder value in these applications where changing the 'this' binding is inconsequential.
ES6 now uses the spread operator '...' which allow you to syntactically spread out an array as parameters without the need for the more generalized apply(..) method. There is still no ES6 substitute for currying with the bind(..) method, so this still needs to be kept in mind.
The downside to passing null to these methods as a 'this' binding is that if it gets passed to a function (for example a third-party library function that you don't understand or is subject to change) and it does make a 'this' reference, the default binding rule means it may inadvertently reference (or even mutate) the global object (which is window in the browser).

-Safer 'this'-
A better alternative to passing 'null' as a this binding in scenarios that require these methods is to instead create an empty, non-delegated, placeholder object and pass that, circumventing any potential problematic side-effects that could have happened upon the global object.
Author names this object with the lowercase mathematical symbol for an empty set (ø) which can be entered in Windows by typing ALT+0248. It also stylistically conveys "I want this empty" better than just using 'null'.
The easiest way to set the object up as totally empty is by using Object.create(null), which is similar to { }, but without the delegation to Object.prototype, essentially making it "more empty" than { }.

-Indirection-
It is possible to create "indirect references" to functions, which then result in default binding rules being applied when that function is invoked.
One way an indirect reference might be made is with an assignment expression that assigns implicitly bound function to another implicitly bound function. This would result in value that is just a reference to the underlying function object, giving it a plain, undecorated call-site, which would utilize default binding rules.

-Softening Binding-
While hard binding prevents a function call from falling back to default binding (unless you use the 'new' operator), it reduces the flexibility of a function by preventing the use implicit or explicit overrides.
One way around this restriction is to construct a custom soft binding utility that allows you to set a different default instead of the usual global/undefined, while also allowing manual binding via the explicit and implicit binding techniques. You would wrap your specified function in logic that checks 'this' at call-time, check for global/undefined, and if found, replace it with a pre-defined default object. Otherwise, 'this' would be left untouched. You could also include the same currying functionality that is offered with bind(..).

-Lexical 'this'-
ES6 introduces a new special type of function that does not follow the previous 4 binding rules that were covered: The arrow function.
Arrow functions lexically adopt the binding of the enclosing (function or global) scope created at call-time and bind it to 'this'.
The lexical binding of an arrow-function can not be overridden, even by 'new'.
Arrow functions will most commonly be used in callbacks such as timers and event handlers.
A pre-ES6 pattern used to disable the traditional `this` mechanism in favor of lexical scoping was to create a variable reference to `this` in the enclosing function, and then using that variable in place of any `this` reference within your enclosed function.
Author opines that it's best not to mix lexical and `this` mechanisms in the same functions or even types of look-ups.

-Review-
Determining `this` binding:
1. Called with `new`? Use the newly constructed object.
2. Called with `call` or `apply`? Use the object specified.
3. Called with context object owning the call? Use the specified context object.
4. Default is `undefined` in strict mode, otherwise global object.
Beware of unintentionally invoking the default binding rule. To safely ignore a `this` binding, you can create a DMZ-like object (ø = Object.create(null)) as a placeholder value to protect global from unintended misuse.
ES6 arrow functions throw traditional `this` binding rules out the window in favor of lexical scoping rules, adopting `this` binding from the enclosing function call. They are a replacement of the `self = this` trick used in pre-ES6 coding.

===========================================Chapter 3===========================================
Objects

-Syntax-
Objects come in the declarative (literal) form and the constructed form. Both of these result in the same sort of object, with the only difference being that you can add multiple key/value pairs at once using the literal form, whereas you have to add properties individually when using the constructed form.
It's extremely uncommon to use the constructed form. You pretty much always want to use literal syntax. The same applies for built-in objects.

-Type-
Objects are one of 6 of the primary JS types (called "language types" in the specification), which also includes string, number, boolean, null, and undefined.
The simple primitives (the 5 other primary language types) are not themselves objects. `null` is sometimes referred to as an object type, but this is a misconception based on a bug in the language that causes `typeof null` to return a string "object" incorrectly. `null` is its own primitive type.
Everything in JavaScript is not an object.
There are a few special object sub-types, which will be referred to as "complex primitives". `function` is a sub-type that is technically a "callable object". Functions are said to be "first class" in JS, which means they are basically just normal, primary objects with the callable behavior semantics added on. They can be handled like any other regular object.
Arrays are also a form of object, with additional behaviors. The organization is slightly more structured than that of a regular object.

-Built-in Objects-
There are other object subtypes referred to as built-in objects. The relationship of the ones that share a name with their primitives is one of complexity and less-than-direct relation: String, Number, Boolean, Object, Function, Array, Date, RegExp, Error.
They have the appearance of being actual types or even classes if you compare them to other languages, but in JS, they are simply built-in functions. Each of them can be used as a constructor (a function call with a `new` operator), resulting in a newly-constructed object of the sub-type specified.
So basically, the built-in objects are object subtypes that construct the primitive or sub-type that their name refers to.
A string value such as "this is a string" is not an object but in fact a primitive literal and immutable value. To perform operations on it, such as checking its length, accessing individual characters, etc., you would do this via a String object.
The language automatically coerces a string primitive to a String object when necessary, meaning you almost never have to explicity create the built-in Object form. The majority strongly prefer to use the literal form for a value, allowing for implicit coercion over using the explicit constructed form. You can simply call a property or method on a string primitive and have it automatically coerce to a String object so that the property/method access works.
The same coercion occurs between the other literal primitives and their object wrappers.
`null` and `undefined` have no object wrappers, only primitive values.
`Date` values can only be created with their constructed object form, as they have no literal counterpart.
`Object`, `Array`, `Function`, and `RegExp` only exist as objects whether referred to in literal or constructed form. While the constructed form does offer more options in way of object creation, the simpler literal form is almost universally preferred. Only use the constructed form if you need these extra options.
`Error` objects are rarely created explicitly in code. They can be created with the constructed form `new Error(..)`, but this is not usually necessary.

-Contents-
The contents of objects are not necessarily stored inside the object itself, as the engine stores values in implementation-dependent ways in which they may not store them inside of an object container. The property names are stored in their respective objects, which act as pointers (or references, technically) to where the values are stored.
To access a location in an object, you need to either use the . operator (this syntax commonly referred to as property access) or the [ ] operator (commonly referred to as key access).
The `.` operator requires an Identifier-compatible property name after it, whereas the `[".."]` syntax can basically take any UTF-8/unicode-compatible string as the property name, so you would have to use the latter syntax if the property name had extraneous characters that were not acceptable as an Identifier property name.
Using any value other than a string in a property name will result in an attempt to implicitly coerce the value into a string primitive. This can be used to your advantage as you can feed a computed expression value as a key, but it can also cause problems if you for instance confuse using a number as an index (like you would with an array) instead of as a string value.

-Computed Property Names-
While you can easily use the myObj[..] property-access syntax to easily use a computed expression value as a key name, it doesn't provide any utility in the declaration of objects using object-literal syntax.
With ES6, you can now utilize computed property names, which allow you to specify an expression, using brackets [ ] to surround it, in place of the key name in an object-literal declaration.
The most common usage will likely be for the new ES6 Symbols, which are a new primitive data type likely described in the ES6 book.

-Property vs. Method-
In JS, functions never "belong" to objects, so a function that is accessed on an object reference isn't really automatically a method. It's easy to think otherwise, as in other languages, functions which belong to objects (classes), are referred to as methods.
Functions with `this` references referring to the object reference at the call-site are not any more a "method" than any other function, as `this` is dynamically bound at run-time, at the call-site. Its relationship to the object is fairly indirect.
Even if you access a property and receive a function in return, that still qualifies as "property access", rather than "method access", as they are only associated by reference.
Because of this, "function" and "method" are probably interchangeable in JavaScript.
ES6 adds the `super` reference which is typically going to be used with `class`. It uses static binding rather than using the traditional `this`, and gives nuance that a `super`-bound function is more method than function, but this is again a matter of debatable semantics.

-Arrays-
Arrays assume numeric indexing, which means values are stored in locations, called indices, at non-negative integers.
Arrays are objects, which means that even though each index is a positive integer, you can still add properties onto the array. Doing so will not change the reported length of the array.
You could add properties onto an array and never add any numeric indices, although you might as well use objects since arrays have special behaviors and optimizations specific to their purpose, just as plain objects do.
Be aware that when adding a property to an array with a name that resembles a number, the property value will instead end up being appended at the numeric index specified in the property name.

-Duplicating Objects-
When copying an object, you want to consider whether you want to create a shallow copy (just a new object, but any object references contained within still reference the same objects) or a deep copy (where the object and all object references contained are copied).
A problem that could come up is that one of the reference objects points to the main object that referred to it, create an infinite circular reference, causing endless duplication if being deep copied.
Various JS frameworks interpret this problem differently and implement their own solutions.
One solution is that ensure your object is JSON-safe (can be serialized to a JSON string and re-parsed to an object with the same structure and values), which is not always easy to do.
Because a shallow copy is easier to understand and less issue-prone, ES6 has introduced Object.assign(..). Object.assign(..) takes a target as its first parameter, and one or multiple sources for the following parameters. It iterates through all enumerable, owned keys (immediately present), and copies them via = assignment to target, and then returns that target.
Special characteristics on a property, like `writeable`, are not preserved using the shallow `=`-style assignment of Object.assign(..).

-Property Descriptors-
As of ES5, all properties are described in terms of a property descriptor. To get the property descriptor, you use Object.getOwnPropertyDescriptor( myObj, key );
A property descriptor that is only for holding a data value is called a data descriptor.
Other than the value, property descriptors also contain three other characteristics, `writable`, `enumerable`, and `configurable`.
You can use Object.defineProperty(..) to add a new property or modify existing ones (if `configurable`). You normally wouldn't manually add a property in this way unless you wanted to modify one of its descriptor characteristics differently than normal.

-Writable-
`writable` is the ability to change a property.
If you attempt to modify a non-writable property in strict mode, a TypeError will be thrown. In non-strict mode, the change will just silently fail.
`writable:false` is somewhat equivelent to if you defined a no-op setter, but would need to throw a TypeError when called to be conformant to `writeable:false`.

-Configurable-
If a property is not currently configurable, you will not be able to modify its descriptor definition using the Object.defineProperty(..) utility. Any attempt to do so will throw a TypeError, regardless of strict mode settings. The only exception is that writable can be changed from true to false without error (does not apply for changing it from false to true).
Setting a property to be non-configurable is a one-way action that cannot be undone.
`configurable:false` also prevents the ability to use the `delete` operator to remove the property. An attempt to delete in this situation will silently fail in non-strict mode and throw a TypeError in strict mode.
If an object property is the last remaining reference to an object, and you `delete` it, the now unreferenced object can be garbage collected. According to author, it is not proper to think of `delete` as a memory-freeing tool, as it is in other languages, but rather a simple object property removal operation.

-Enumerable-
This property characteristic determines whether a property will show up in particular object-property enumerations, such as `for..in` loops.
All user-defined properties are defaulted to `enumerable`.

-Immutability-
ES5 adds support for making objects and properties immutable. All of the approaches availed create shallow immutability, only affecting the object and its direct property characteristics. The contents of references to other objects will remain mutable.
According to author, it is not common to create deep immutable objects in JS, and not advisable as a heavy-use design pattern.

-Object Constant-
Combining `writable:false` with `configurable:false` turns an object property into what is essetially an object constant.
 
-Prevent Extensions-
Call Object.preventExtensions(..) to prevent an object from being able to have new properties added to it, while leaving the rest of the object's properties alone.
Attempting to add a property to an object that has extensions prevented will result in a TypeError being thrown in strict mode, otherwise the addition will silently fail.

-Seal-
Object.seal(..) does the same thing as Object.preventExtensions(..) but also sets all existing properties to `configurable:false`, preventing the ability to configure or delete them (although you can still modify their values).

-Freeze-
Object.freeze(..) provides the highest level of immutability for an object, by performing the equivalent of Object.seal(..) upon it, and then additionally setting all 'data accessor' properties as `writable:false` so that their values can't be changed. You cannot change the object or any of its properties. The contents of any referenced objects remain unaffected.
You could recursively iterate through an object's references and call Object.freeze(..) on each of them to "deep freeze" an object, but you have to be careful not to affect other shared objects you weren't attempting to freeze.

-[[Get]]-
When you access a property via dot or bracket notation, you are not just looking for a property of that name in the object. You are actually performing a [[Get]] operation (sort of like a function call) on the object. 
By default, the operation first checks the object for a property of that name, and then returns the value if it is found.
If [[Get]] cannot come up with a value, it instead returns `undefined`. This contrasts variable identifier lookups, which throws a `ReferenceError` instead.

-[[Put]]-
[[Put]] is the operation for setting a property value.
[[Put]]'s behavior is based on whether the property it's trying to assign a value to is already present or not.
If the property is present, [[Put]] will first check if it's an accessor descriptor and call the setter if so. Otherwise, it will check if the property is a data accessor with `writeable:false` and silent error or TypeError based on strict mode settings. If neither of these are applicable, [[Put]] will set the value to the property as usual.
If the property is not present, [[Put]] undergoes an even more complex series of operations.

-Getters & Setters-
The default [[Get]] and [[Put]] operations completely control operations for setting and retrieving property values. They can/may be completely overridden using advanced/future JS capabilities, and partially overridden on a per-property level as of ES5 via the use of getters and setters.
Getters are properties that call a hidden function to retrieve a value, and setters properties that call a hidden function to set a value.
Properties become accessor descriptors (instead of a data descriptor) when they have been defined to have a getter/setter/both. The `value` and `writeable` characteristics are ignored, with JS considering the `get`, `set`, `configurable`, and `enumerable` being availed to accessor descriptors.
You can define a getter property through either object-literal syntax (`get a() {..}' as a property) or explicit definition with Object.defineProperty(..) that, instead of holding a value, will access a hidden getter function that returns a value upon its invocation. Whatever value this function returns will be the result of the property access.
When you only define a getter with a hardcoded return value for a property, you will be unable to reassign its value, instead having it silently thrown away. Because of this, you should also define a setter as well for each accessor descriptor property in order to override the default [[Put]] operation (the act of assignment).

-Existence-
You can see if a property exists without getting its value by using the `in` operator ( `("prop" in myObject)` ). It checks whether the property is "in" the object or at a higher level of the [[Prototype]] chain. It's actually just checking to see if the given property name exists, not for a value itself.
Another way is using the hasOwnProperty(..) object method, which only checks to see if the property exists in the object referenced. It does not check the [[Prototype]] chain.
A method call like `myObject.hasOwnProperty(..)` would fail on an object that does not link to `Object.prototype` via `Object.create(null)`. A more thorough way to check is to use `Object.prototype.hasOwnProperty.call(yourObject, "prop")`, which calls the base `hasOwnProperty(..)` method its `this` value bound to your object.

-Enumeration-
An object property being enumerable essentially means that it will be included if an object's properties are iterated through.
An NON-enumerable object property exists and has an accessible value and will even show via the `in` operator check, it will not show in a `for..in` loop.
Using a `for..in` loop on an array produces both the numeric indices as well as any enumerable properties on the array object. For that reason, it is usually best to use traditional `for` loops on arrays, as they stick to numeric index iteration only, and only using `for..in` loops on objects.
`propertyIsEnumerable(..)` checks if a given property name both exists directly on an object and if that property is `enumerable:true`.
`Object.keys(..)` returns an array containing all enumerable properties located directly on an object.
`Object.getOwnPropertyNames(..)` returns an array containing all properties located directly on an object, regardless of their enumerability.
There is currently no built-in way of iterating through properties on an object up through all levels of the [[Prototype]] chain, in a fashion similar to the way the `in` operator would check an object for a single property, but you can enact such utility by recursively traversing through each [[Prototype]] level in the chain, capturing the `Object.keys(..)`  list each loop, which would pull all enumerable properties from that level.

-Iteration-
When iterating over the values of a numerically-indexed array using a `for` loop, you are iterating over the indices, rather than the values, and then using each index in the loop to reference the value as `yourArray[i]`. Similar applies with iterating on an object using a `for..in` loop, as you are iterating through enumerable properties and then having to manually access properties for values.
ES5 added several iteration helpers for arrays. They are: `forEach(..)`, `every(..)`, and `some(..)`. They all accept a function callback to apply to each array element.
`forEach(..)` iterates over all array values, ignoring any callback return values.
`every(..)` keeps iterating until it reaches the end or until a falsy value is returned by the callback. `some(..)` is the same as `every(..)`, except it will instead end if a truthy value is returned by the callback. These act similar to a `break` statement inside of a normal `for` loop.
Unlike the numerical indices of an array, iterating an object's properties will not necessarily result in consistent ordering, as it may differ between JS engines.
ES6 adds a `for..of` loop for iterating values of array (and objects with custom-defined iterators) directly, with no need to reference the value of the current index in each loop like you would with `for..in`.
`for..of` iterates the return values of a "thing"'s iterator object (derived from a default internal function called `@@iterator`) provided by calling the iterator object's `next()` method each loop until a return of the property characteristic `done:true` is returned.
You can get at the `@@iterator` internal property of an object (either an array object or regular object with a self-defined `@@iterator`) using the ES6 `Symbol` computed property name in the form of `Symbol.iterator`. You'll always want to reference/resolve special properties such as these using `Symbol` instead of the special value they may hold, because the actual value may vary based on JS engine being used. Also keep in mind that `@@iterator` is not the iterator object, but a function that returns said object.
You can create a custom `@@iterator` function for an object using `Object.defineProperty` to define `Symbol.iterator`, ensuring it returns a function value that contains an appropriately-implemented `next()` method that both iterates and returns each value and iteration completion status (`done`) as. You also want to set the enumarable property descriptor characteristic to `enumerable:false`. Another way of doing this is to declare a custom `@@iterator` function directly on the object during its declaration using a key of `[Symbol.iterator]`.
You can define more complex iterators for your custom data structures, which can become quite powerful tools for manipulating user-defined objects when used in combinated with ES6's 'for..of` loop. As long as the iterator returns expected `{ value: .. }` return values from `next()` calls and `{ done: true }` after iteration completes, it will work with the `for..of` loop.
You can generate "infinite" iterators for the sake of always returning a random or incremented value, a unique identifier, etc., although you wouldn't want to use these iterators with an unbounded `for..of` loop, as that would result in a program-hanging infinite loop.

-Review-
Objects come in literal and constructed forms, with literal preferred most of the time and constructed only used in certain circumstances where either additional creation options are needed, or the constructor-only forms are available (such as with the `Date(..)` object).
Objects are only one of the 6/7 primitive types in JS. Objects have sub-types such as `function` and the behavior-specialized `[object Array]'.
Whenever a property is accessed on an object, the engine invokes the internal default `[[Get]]` operation (or `[[Put]]` for setting values), which looks for the property directly on the object, and then traverses up the `[[Prototype]]` chain to search further if not found.
Properties have characterstics which can be accessed through property descriptors, such as `enumerable` and `writable`. Objects can have their (and their properties') mutability set to varying levels of immutability using Object methods such as `Object.preventExtensions(..)`, `Object.freeze(..)`, and `Object.seal(..)`.
Properties can be "accessor properties" rather than "data properties", using getters/setters. They can also be set to `enumerable:false`, which prevents them from showing in enumeration loops such as `for..in`.
You can iterate the values in any given data structure using the ES6 `for..of` loop syntax, which seeks a built-in/custom `@@iterator` object containing a `next()` method to advance through each data value one at a time, and perform additional, custom-defined actions as desired.

===========================================Chapter 4===========================================
Mixing (Up) "Class" Objects

-Class Theory-
OO/class-oriented programming encapsulates behavior and data together, since data always has associated behaviors that operate on it. These are sometimes called data structures in formal computer science. An example of this is the string manipulation methods designed as part of the `String` class. All strings provided are an instance of this class, so both the data and the built-in functionality for manipulating that data are packaged (encapsulated) in the same location.
Classes imply a way of classifying a certain data structure, by categorizing a given structure as a specific variation of a more generalized base definition. For example, a `Car` class inheriting (or extending) from a `Vehicle` class.
Polymorphism is the concept that a child class can override a behavior from its more generalized parent class in order to give it more specifics. Relative polymorphism allows you to reference the base behavior from the overridden behavior.
Class theory strongly pushes using the same method name for both parent and child classes that share a certain behavior, although doing so in JS is apparently not an easy thing to do.

-"Class" Design Pattern-
Procedural programming, used by languages such as FORTRAN and BASIC, only consist of procedures (functions) calling other functions, without any higher abstraction. You can write procedural code in pretty much any language, although you end up with the often-dreaded "spaghetti code".
The use of classes are often recommended as the way to minimize spaghetti code, although with "functional languages" you will find that they are just one of many optional over-arching design patterns.
Some languages, such as Java, limit you to the confines of class-oriented programming, where design patterns are subservient to the class structure.
Other languages, such as C/C++ and PHP, provide both procedural and class-oriented options, giving developers a choice as to the mixture of style they would like to use.

-Javascript "Classes"-
Although the language has some class-like syntactic elements such as `new` and `instanceof` and (as of ES6) includes the `class` keyword, JavaScript does not really have classes.
Since class structure is a design pattern, you can include approximations for most classical class functionality in JS, although the underlying mechanisms function quite differently than what these implementations show on the surface. They are an optional design pattern, and you can either use them in JS or not.

-Class Mechanics-
With a class-oriented language, the standard library typically provides a stack data structure (push, pop, etc.) as a `Stack` class. The class provides you with publicly accessible methods that give your code the ability to interact with the hidden data variables (adding/removing/etc.).
Unless making a `Static` class member reference, you don't truly operate on the stack in such languages. `Stack` is merely an abstract definition of what a stack would do. You still have to instantiate the `Stack` class before you have a concrete data structure "thing" to operate upon.

-Building-
To use the building analogy, a class is the building blueprint. To instantiate that class is to create a physical (constructed) copy of those plans (an object), typically called an instance. It is only this instance (not the class "blueprint" itself) that we can directly call methods and access exposed data properties from.
While an object can't generally directly access and manipulate its class, it's usually possible to determine the class an instantiated object came from.
"A class is instantiated into object form by a copy operation."

-Constructor-
Class instances are constructed by a special method of the class called the constructor, usually having the same name as the class itself. The job of the constructor method is to initialize the instance with any data (state) the instance will need.
Class constructors belong to their classes, and almost always need to be called with the `new` keyword to let the language know you want to construct a new instance of a class.

-Polymorphism-
Relative polymorphism is the concept that a method can reference and inherit from another method, that it is overriding, that exists on a higher level (one level) up the hierarchy without absolutely defining which inheritance level (class) is to be accessed.
In many class-oriented languages, the keyword `super` is used to denote relative inheritance up one level to the parent class. It's also useful with real classes because you can reference the constructor of a parent class from the constructor of a child class. This works because the constructor "belongs" to its containing class.
The same does not apply in JS, as the "class" moreso belongs to the constructor. The parent/child relationship only exists between the `.prototype` objects of their respective constructor objects, the constructors are not directly related themselves (although ES6's `class` attempts to solve this with `super`).
In class-oriented languages, if you have a class that inherits a function using `super` relative inheritance, and that function references another member that exists on both child and parent class, the language engine will reference the function on the child class. If the child class instantiated the parent class as an object and then called that function, the engine would use the parent classes' function definition. The definition for the referenced method "polymorphs" (changes) based on which class (level of inheritance) you're referencing an instance of.
A child class is only given a copy of the inherited behavior from its parent class. This means that if a child overrides a method it inherits, both the original parent overridden versions of the method are preserved. Polymorphism does not imply the linking of classes. Class inheritance implies copies.

-Multiple Inheritance-
Multiple inheritance means that multiple parent class definitions are copied into a child class.
Problems can arise with such usage, some pertaining to the potential of inheriting multiple members of the same type and name.
JavaScript does not include a native mechanism for multiple inheritance, although developers have faked such functionality in various ways.

-Mixins-
In JavaScript, there are no "classes", and there is no automatic copy behavior when one "inherits" or "instantiates". There are only objects, and rather than copy objects to other objects, they are instead linked together.
Javascript developers fake this copying class behavior via the use of mixins.
There are two types of mixins: Explicit and implicit.

-Explicit Mixins-
Since JS doesn't automatically copy behavior from one object to another, you can create and use a utility to manually copy the properties over. This is a mixin, but is often referred to in code as an `extend(..)` method by many libraries and frameworks.
The mixin utility essentially iterates each key from the source object, checks to make sure it doesn't already exist in the target object (skipping over if it does), and adds each property to the target object.
Function references, rather than the functions themselves, are actually copied to the target object when mixing in a source object.

-"Polymorphism" Revisited-
Since there is no relative polymorphism in JS (prior to ES6), instead you must make an absolute (rather than relative) reference that specifies both the object and function by name. An example is `ParentObject.function.call( this ). This ensures the function call is bound to and executed from the context of the child object you are calling from. You could call this "explicit pseudo-polymorphism".
You have to use this more explicit pseudo-polymorphism when your `mixin(..)`/`extend(..)` call does not copy over a property/function reference due to the property/function name identifier of the parent/source object overlapping ("shadowing") with one in the child/target object.
In class-oriented languages with relative polymorphism, class linkage is established one time at the top of the class definition. In JavaScript, this pseudo-polymorphic linkage has to be explicitly implied for every function reference with identifier overlap shadow. This manual/explicit linkage is brittle in comparison to it's class-oriented counterpart.
Explicit pseudo-polymorphism can also emulate multiple inheritance, but this only increases the brittleness and complexity of your objects.
According to the author, explicit pseudo-polymorphism should be avoided whenever possible.

-Mixing Copies-
Manually copying functions (using mixins) in JS still does not actually emulate the real duplication of a class to an instance that would occur in class-oriented languages. You can only duplicate a function reference. If you modify a shared function object, for example by adding properties to it, any objects that share the duplicated reference would be affected.
Not much benefit is derived from copying properties from one object to another versus just defining the properties twice, once on each object (especially when function-object references are made).
There is also no way to handle multiple inheritence method/property collisions, although some libraries have devised a "late binding" technique, among other workarounds. According to the author, they tend to require more effort and less performance than you are actually getting from the payoff.
Try to only use explicit mixins when it helps make your code more readable. Avoid it where it makes code harder to trace and dependencies between objects overcomplicated. There are better ways to accomplish these desired outcomes, to be outlined.
