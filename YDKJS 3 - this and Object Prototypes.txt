===========================================Chapter 1===========================================
'this' Or That?

-Why this?-
The 'this' keyword allows functions to be reused against multi-context objects, instead of needing a separate function for each object.
The 'this' mechanism provides an elegant way to implicitly pass an object reference, which leads to cleaner and more reusable API design. Passing along parameters in increasingly complex usage patterns becomes cumbersome and messier than simply passing things through the 'this' context.

-Confusions: Itself-
'this' does not refer to or root in the enclosing function itself.
You can add a property to a function but using 'this' to access a property of the same name will not necessarily refer to that function object.
Devs who fail to understand the 'this' keyword often fall back onto lexical scope at this point and just create a new object.
If you need to access a function's object, you can use a named function and refer to it using its identifier.
Do not use anonymous functions if they will be referring to themselves. There is an arguments.callee reference that was used in anonymous functions, but it is now deprecated. Use a named function expression instead.
To use 'this' in such a situation, you would force 'this' to point to the function object using the call() method on the function, which executes the function while allowing you to provide a value to 'this' (in this case, the function you want to refer to).

-Confusions: Its Scope-
'this' does not in any way refer to a functions lexical scope. While internally, scope is sort of like an object with properties of each available identifier, this is only accessible to the JS engine itself, and not the code.
You cannot bridge two scopes together by invoking one from the other leading with the 'this' keyword.

-What's this?-
'this' is a run-time binding, rather than an author-time binding. It has everything to do with how a function is called.
When you invoke a function, an activation record (or execution context) is created. It contains info on where the function was called from (the call-stack), how it was invoked, what parameters were passed, etc. One of the properties of this record is the 'this' reference that will be used for the duration of that function's execution.
Finding a function's call-site will determine how its execution will bind 'this'.

===========================================Chapter 2===========================================
'this' All Makes Sense Now!

-Call-site-
The call-stack is essentially the chain of functions called in order to get to whatever location your code is currently at in execution.
The call-site is the location (function or global) in which the function you have currently stepped into was invoked.
You can use a JS debugger in your browser by setting a breakpoint at the beginning of a function or insert a 'debugger;' statement in the same location to cause the debugger to pause and show you the call-site/stack for each invocation of that function when the code is executed.

-Nothing But Rules: Default Binding-
Variables declared in global scope are synonymous with global-object properties of the same name.
The default binding applies to the function call, so if the function was called from global, then 'this' would point to the global object.
When a function is called with a plain, undecorated function reference, default binding is the only type that would apply.
In strict mode, the global object is not eligible for default binding. 'this' would be set to undefined in a function with a global call-site. This would only apply if your function contents were set to strict mode. The state of the call-site is irrelevant.
Author opines that you should not mix non-strict with strict mode, although sometimes this is unavoidable due to the inclusion of third-party libraries.
