===========================================Chapter 1===========================================
'this' Or That?

-Why this?-
The 'this' keyword allows functions to be reused against multi-context objects, instead of needing a separate function for each object.
The 'this' mechanism provides an elegant way to implicitly pass an object reference, which leads to cleaner and more reusable API design. Passing along parameters in increasingly complex usage patterns becomes cumbersome and messier than simply passing things through the 'this' context.

-Confusions: Itself-
'this' does not refer to or root in the enclosing function itself.
You can add a property to a function but using 'this' to access a property of the same name will not necessarily refer to that function object.
Devs who fail to understand the 'this' keyword often fall back onto lexical scope at this point and just create a new object.
If you need to access a function's object, you can use a named function and refer to it using its identifier.
Do not use anonymous functions if they will be referring to themselves. There is an arguments.callee reference that was used in anonymous functions, but it is now deprecated. Use a named function expression instead.
To use 'this' in such a situation, you would force 'this' to point to the function object using the call() method on the function, which executes the function while allowing you to provide a value to 'this' (in this case, the function you want to refer to).

-Confusions: Its Scope-
'this' does not in any way refer to a functions lexical scope. While internally, scope is sort of like an object with properties of each available identifier, this is only accessible to the JS engine itself, and not the code.
You cannot bridge two scopes together by invoking one from the other leading with the 'this' keyword.

-What's this?-
'this' is a run-time binding, rather than an author-time binding. It has everything to do with how a function is called.
When you invoke a function, an activation record (or execution context) is created. It contains info on where the function was called from (the call-stack), how it was invoked, what parameters were passed, etc. One of the properties of this record is the 'this' reference that will be used for the duration of that function's execution.
Finding a function's call-site will determine how its execution will bind 'this'.

===========================================Chapter 2===========================================
'this' All Makes Sense Now!

-Call-site-
The call-stack is essentially the chain of functions called in order to get to whatever location your code is currently at in execution.
The call-site is the location (function or global) in which the function you have currently stepped into was invoked.
You can use a JS debugger in your browser by setting a breakpoint at the beginning of a function or insert a 'debugger;' statement in the same location to cause the debugger to pause and show you the call-site/stack for each invocation of that function when the code is executed.

-Nothing But Rules: Default Binding-
Variables declared in global scope are synonymous with global-object properties of the same name.
The default binding applies to the function call, so if the function was called from global, then 'this' would point to the global object.
When a function is called with a plain, undecorated function reference, default binding is the only type that would apply.
In strict mode, the global object is not eligible for default binding. 'this' would be set to undefined in a function with a global call-site. This would only apply if your function contents were set to strict mode. The state of the call-site is irrelevant.
Author opines that you should not mix non-strict with strict mode, although sometimes this is unavoidable due to the inclusion of third-party libraries.

-Implicit Binding-
If the call-site has a context object (an object reference precedes the function call), you could say the context 'owns' or 'contains' the function reference at the time the function is called.
The implicit binding rule demands that the context object is what should be used for the function call's 'this' binding.
'this.a' would be synonymous with 'obj.a'
Only the last or top level of the object reference property chain matters to the call-site when determining what should be used for the 'this' binding.

-Implicitly Lost-
If you create a new reference to the previous function call that is preceded by an object reference and then call that reference in a plain, undecorated fashion, default binding rules will apply. This is because the new reference is really just another reference to the function call itself. The call-site is what matters, so if it's simply a global, undecorated function call, you would have a value of global or undefined bound to that function's 'this' value, depending on your strict mode settings.
The same rule applies when passing a callback function. The preceding object reference in the passed function is essentially stripped out. Parameter passing is just an implicit assignment, so passing a function is an implicit reference assignment.
Another way 'this' can be of surprise is when functions you've passed your callback to intentionally change the 'this' reference for the call. Event handlers in popular JS libraries will frequently force your callback to have a 'this' which points to something such as the DOM element that triggered the event.

-Explicit Binding-
Explicit binding allows you to force a function call to use a specific object for the 'this' binding without putting a property reference on the object, like you would do with implicit binding.
The vast majority of functions have some utilities made available to them via their [[Prototype]] that can be useful for this, specifically the call(..) and apply(..) methods. Both of these methods take an object to use for 'this' as their first parameter, and then invoke it using the specified 'this'. This is an example of explicit binding.
If you pass a primitive value of type 'string', 'boolean', or 'number' as the 'this' binding, the primitive value is wrapped in its object form (new String(..), new Boolean(..), etc). This is commonly referred to as "boxing".
'call' and 'apply' are identical in respect to 'this' binding, although they do behave differently with their additional parameters.

-Hard Binding-
Explicit binding alone does not address the previous issue of a function losing its intended 'this' binding, being superceded by a framework, etc, but the hard binding variation of explicit binding does take care of this.
To hard bind, you create a function that forcibly invokes your target function using the call(..) or apply(..) method, explicitly binding its 'this' keyword to the object you specify. No matter how you later invoke the containing function, it will always manually invoke your target function with the object you specified bound to 'this'. This is called hard binding, which is both explicit and robust.
The most common way to wrap a function with a hard binding is to use the apply method to create a pass-thru of any received value: (apply( obj, arguments ))
Another way to express the hard binding pattern is to create a re-usable helper. This helper function would take both the function to be bound and the object to bind as parameters and would return a function that would bind them together and pass any additional arguments provided using the apply method. You'd then assign this bind function to a var and pass any of your additional arguments when you call that function.
This feature is actually a built-in method in ES5 as bind(..), which returns a new function that is hard-coded to call the original function using whatever object parameter you passed as the 'this' context.
In ES6, any function produced by the bind(..) method should have a .name property that provides you the original target function. For example, `bar = foo.bind` would result in bar.name giving a value of "bound foo".

-API Call "Contexts"-
Many library functions and new built-in JS functions provide a parameter, usually called "context", that is designed as a work-around to using bind(..).
Internally, these functions most likely use call(..) or apply(..) to explicitly bind behind the scenes to ensure a callback function uses a specified 'this'.

-'new' Binding-
The code pattern to use the 'new' operator in JS looks pretty much identical to the way it would be used in a class-oriented language, which would call the constructor for a newly instantiated class. However, JS does not have any connection to class-oriented functionality when using 'new'.
In JS, a constructor is basically just a function that is called with a 'new' operator in front of it. They are not attached to nor do they instantiate a class. They are regular functions that are hijacked by the use of 'new' in their invocation.
Pretty much any function, including built-in ones such as Number(..) can be called with 'new' in front of it, and that makes the function call a constructor call. There is no such thing as a constructor function, only a constructor call of a function.
When you invoke a function with new in front of it, also known as invoking a constructor call: 
	1. A brand new object is created (constructed), initialized by the function you called. 
	2. The newly-constructed object is [[Prototype]]-linked. 
	3. The newly-constructed object is set as the 'this' binding for that function call. 
	4. Unless the function returns its own alternate object, the 'new'-invoked function call will automatically return the newly-constructed object.
'new' is the final way that a function's 'this' can be bound, hence the name of 'new' binding'.

-Everything In Order-
When dealing with a situation where multiple rules are applied, default binding is the lowest-priority rule of the four bindings.
Explicit binding always takes precedence over implicit binding.
'new' binding is more precedent than implicit binding.
'new' and call/apply cannot be used together, but you can use hard binding to (less directly) test explicit binding against 'new' binding.
Recall that hard binding uses Function.prototype.bind(..) to create a new wrapper function that eschews its own 'this' binding in exchange for one that is manually provided.
The prototype bind(..) function has code built into it that gives 'new' binding more precedence over explicit binding. This is useful because you can still use the capability of bind(..) to pass arguments after the first 'this'-binding argument that will then be defaulted as standard arguments to the underlying function, while ignoring the 'this' hard-binding. This technique is called "partial application", which is a subset of "currying".

-Determining 'this'-
1. Is the function called with the 'new'? If so, 'this' is the newly constructed object (new binding).
2. Is the function called with the 'call' or 'apply' methods, or hidden inside a 'bind' hard binding? If so, 'this' is an explicitly specified object (explicit binding).
3. Is the function called with a context, otherwise known as an owning or containing (or preceding) object? If so, 'this' is that context object (implicit binding).
4. Otherwise, default the 'this'. If in strict mode, it will be undefined. If in non-strict mode, 'this' will be the global object.

-Binding Exceptions: Ignored 'this'-
There are some exceptions to the above rules that will result with the default binding rule being applied unexpectedly.
If you pass null or undefined as a 'this' binding parameter to the call/apply/bind methods, those values will be ignored and default binding rules will apply. This is sometimes used as the apply method is commonly used to spread out arrays of values as parameters to a function call. bind(..) can also curry out values as parameters in a similar fashion. 'null' works as a placeholder value in these applications where changing the 'this' binding is inconsequential.
ES6 now uses the spread operator '...' which allow you to syntactically spread out an array as parameters without the need for the more generalized apply(..) method. There is still no ES6 substitute for currying with the bind(..) method, so this still needs to be kept in mind.
The downside to passing null to these methods as a 'this' binding is that if it gets passed to a function (for example a third-party library function that you don't understand or is subject to change) and it does make a 'this' reference, the default binding rule means it may inadvertently reference (or even mutate) the global object (which is window in the browser).

-Safer 'this'-
A better alternative to passing 'null' as a this binding in scenarios that require these methods is to instead create an empty, non-delegated, placeholder object and pass that, circumventing any potential problematic side-effects that could have happened upon the global object.
Author names this object with the lowercase mathematical symbol for an empty set (ø) which can be entered in Windows by typing ALT+0248. It also stylistically conveys "I want this empty" better than just using 'null'.
The easiest way to set the object up as totally empty is by using Object.create(null), which is similar to { }, but without the delegation to Object.prototype, essentially making it "more empty" than { }.

-Indirection-
It is possible to create "indirect references" to functions, which then result in default binding rules being applied when that function is invoked.
One way an indirect reference might be made is with an assignment expression that assigns implicitly bound function to another implicitly bound function. This would result in value that is just a reference to the underlying function object, giving it a plain, undecorated call-site, which would utilize default binding rules.

-Softening Binding-
While hard binding prevents a function call from falling back to default binding (unless you use the 'new' operator), it reduces the flexibility of a function by preventing the use implicit or explicit overrides.
One way around this restriction is to construct a custom soft binding utility that allows you to set a different default instead of the usual global/undefined, while also allowing manual binding via the explicit and implicit binding techniques. You would wrap your specified function in logic that checks 'this' at call-time, check for global/undefined, and if found, replace it with a pre-defined default object. Otherwise, 'this' would be left untouched. You could also include the same currying functionality that is offered with bind(..).

-Lexical 'this'-
ES6 introduces a new special type of function that does not follow the previous 4 binding rules that were covered: The arrow function.
Arrow functions lexically adopt the binding of the enclosing (function or global) scope created at call-time and bind it to 'this'.
The lexical binding of an arrow-function can not be overridden, even by 'new'.
Arrow functions will most commonly be used in callbacks such as timers and event handlers.
A pre-ES6 pattern used to disable the traditional `this` mechanism in favor of lexical scoping was to create a variable reference to `this` in the enclosing function, and then using that variable in place of any `this` reference within your enclosed function.
Author opines that it's best not to mix lexical and `this` mechanisms in the same functions or even types of look-ups.

-Review-
Determining `this` binding:
1. Called with `new`? Use the newly constructed object.
2. Called with `call` or `apply`? Use the object specified.
3. Called with context object owning the call? Use the specified context object.
4. Default is `undefined` in strict mode, otherwise global object.
Beware of unintentionally invoking the default binding rule. To safely ignore a `this` binding, you can create a DMZ-like object (ø = Object.create(null)) as a placeholder value to protect global from unintended misuse.
ES6 arrow functions throw traditional `this` binding rules out the window in favor of lexical scoping rules, adopting `this` binding from the enclosing function call. They are a replacement of the `self = this` trick used in pre-ES6 coding.

===========================================Chapter 3===========================================
Objects

-Syntax-
Objects come in the declarative (literal) form and the constructed form. Both of these result in the same sort of object, with the only difference being that you can add multiple key/value pairs at once using the literal form, whereas you have to add properties individually when using the constructed form.
It's extremely uncommon to use the constructed form. You pretty much always want to use literal syntax. The same applies for built-in objects.

-Type-
Objects are one of 6 of the primary JS types (called "language types" in the specification), which also includes string, number, boolean, null, and undefined.
The simple primitives (the 5 other primary language types) are not themselves objects. `null` is sometimes referred to as an object type, but this is a misconception based on a bug in the language that causes `typeof null` to return a string "object" incorrectly. `null` is its own primitive type.
Everything in JavaScript is not an object.
There are a few special object sub-types, which will be referred to as "complex primitives". `function` is a sub-type that is technically a "callable object". Functions are said to be "first class" in JS, which means they are basically just normal, primary objects with the callable behavior semantics added on. They can be handled like any other regular object.
Arrays are also a form of object, with additional behaviors. The organization is slightly more structured than that of a regular object.

-Built-in Objects-
There are other object subtypes referred to as built-in objects. The relationship of the ones that share a name with their primitives is one of complexity and less-than-direct relation: String, Number, Boolean, Object, Function, Array, Date, RegExp, Error.
They have the appearance of being actual types or even classes if you compare them to other languages, but in JS, they are simply built-in functions. Each of them can be used as a constructor (a function call with a `new` operator), resulting in a newly-constructed object of the sub-type specified.
So basically, the built-in objects are object subtypes that construct the primitive or sub-type that their name refers to.
A string value such as "this is a string" is not an object but in fact a primitive literal and immutable value. To perform operations on it, such as checking its length, accessing individual characters, etc., you would do this via a String object.
The language automatically coerces a string primitive to a String object when necessary, meaning you almost never have to explicity create the built-in Object form. The majority strongly prefer to use the literal form for a value, allowing for implicit coercion over using the explicit constructed form. You can simply call a property or method on a string primitive and have it automatically coerce to a String object so that the property/method access works.
The same coercion occurs between the other literal primitives and their object wrappers.
`null` and `undefined` have no object wrappers, only primitive values.
`Date` values can only be created with their constructed object form, as they have no literal counterpart.
`Object`, `Array`, `Function`, and `RegExp` only exist as objects whether referred to in literal or constructed form. While the constructed form does offer more options in way of object creation, the simpler literal form is almost universally preferred. Only use the constructed form if you need these extra options.
`Error` objects are rarely created explicitly in code. They can be created with the constructed form `new Error(..)`, but this is not usually necessary.

-Contents-
The contents of objects are not necessarily stored inside the object itself, as the engine stores values in implementation-dependent ways in which they may not store them inside of an object container. The property names are stored in their respective objects, which act as pointers (or references, technically) to where the values are stored.
To access a location in an object, you need to either use the . operator (this syntax commonly referred to as property access) or the [ ] operator (commonly referred to as key access).
The `.` operator requires an Identifier-compatible property name after it, whereas the `[".."]` syntax can basically take any UTF-8/unicode-compatible string as the property name, so you would have to use the latter syntax if the property name had extraneous characters that were not acceptable as an Identifier property name.
Using any value other than a string in a property name will result in an attempt to implicitly coerce the value into a string primitive. This can be used to your advantage as you can feed a computed expression value as a key, but it can also cause problems if you for instance confuse using a number as an index (like you would with an array) instead of as a string value.

-Computed Property Names-
While you can easily use the myObj[..] property-access syntax to easily use a computed expression value as a key name, it doesn't provide any utility in the declaration of objects using object-literal syntax.
With ES6, you can now utilize computed property names, which allow you to specify an expression, using brackets [ ] to surround it, in place of the key name in an object-literal declaration.
The most common usage will likely be for the new ES6 Symbols, which are a new primitive data type likely described in the ES6 book.

-Property vs. Method-
In JS, functions never "belong" to objects, so a function that is accessed on an object reference isn't really automatically a method. It's easy to think otherwise, as in other languages, functions which belong to objects (classes), are referred to as methods.
Functions with `this` references referring to the object reference at the call-site are not any more a "method" than any other function, as `this` is dynamically bound at run-time, at the call-site. Its relationship to the object is fairly indirect.
Even if you access a property and receive a function in return, that still qualifies as "property access", rather than "method access", as they are only associated by reference.
Because of this, "function" and "method" are probably interchangeable in JavaScript.
ES6 adds the `super` reference which is typically going to be used with `class`. It uses static binding rather than using the traditional `this`, and gives nuance that a `super`-bound function is more method than function, but this is again a matter of debatable semantics.

-Arrays-
Arrays assume numeric indexing, which means values are stored in locations, called indices, at non-negative integers.
Arrays are objects, which means that even though each index is a positive integer, you can still add properties onto the array. Doing so will not change the reported length of the array.
You could add properties onto an array and never add any numeric indices, although you might as well use objects since arrays have special behaviors and optimizations specific to their purpose, just as plain objects do.
Be aware that when adding a property to an array with a name that resembles a number, the property value will instead end up being appended at the numeric index specified in the property name.

-Duplicating Objects-
When copying an object, you want to consider whether you want to create a shallow copy (just a new object, but any object references contained within still reference the same objects) or a deep copy (where the object and all object references contained are copied).
A problem that could come up is that one of the reference objects points to the main object that referred to it, create an infinite circular reference, causing endless duplication if being deep copied.
Various JS frameworks interpret this problem differently and implement their own solutions.
One solution is that ensure your object is JSON-safe (can be serialized to a JSON string and re-parsed to an object with the same structure and values), which is not always easy to do.
Because a shallow copy is easier to understand and less issue-prone, ES6 has introduced Object.assign(..). Object.assign(..) takes a target as its first parameter, and one or multiple sources for the following parameters. It iterates through all enumerable, owned keys (immediately present), and copies them via = assignment to target, and then returns that target.
Special characteristics on a property, like `writeable`, are not preserved using the shallow `=`-style assignment of Object.assign(..).

-Property Descriptors-
As of ES5, all properties are described in terms of a property descriptor. To get the property descriptor, you use Object.getOwnPropertyDescriptor( myObj, key );
A property descriptor that is only for holding a data value is called a data descriptor.
Other than the value, property descriptors also contain three other characteristics, `writable`, `enumerable`, and `configurable`.
You can use Object.defineProperty(..) to add a new property or modify existing ones (if `configurable`). You normally wouldn't manually add a property in this way unless you wanted to modify one of its descriptor characteristics differently than normal.

-Writable-
`writable` is the ability to change a property.
If you attempt to modify a non-writable property in strict mode, a TypeError will be thrown. In non-strict mode, the change will just silently fail.
`writable:false` is somewhat equivelent to if you defined a no-op setter, but would need to throw a TypeError when called to be conformant to `writeable:false`.

-Configurable-
If a property is not currently configurable, you will not be able to modify its descriptor definition using the Object.defineProperty(..) utility. Any attempt to do so will throw a TypeError, regardless of strict mode settings. The only exception is that writable can be changed from true to false without error (does not apply for changing it from false to true).
Setting a property to be non-configurable is a one-way action that cannot be undone.
`configurable:false` also prevents the ability to use the `delete` operator to remove the property. An attempt to delete in this situation will silently fail in non-strict mode and throw a TypeError in strict mode.
If an object property is the last remaining reference to an object, and you `delete` it, the now unreferenced object can be garbage collected. According to author, it is not proper to think of `delete` as a memory-freeing tool, as it is in other languages, but rather a simple object property removal operation.

-Enumerable-
This property characteristic determines whether a property will show up in particular object-property enumerations, such as `for..in` loops.
All user-defined properties are defaulted to `enumerable`.

-Immutability-
ES5 adds support for making objects and properties immutable. All of the approaches availed create shallow immutability, only affecting the object and its direct property characteristics. The contents of references to other objects will remain mutable.
According to author, it is not common to create deep immutable objects in JS, and not advisable as a heavy-use design pattern.

-Object Constant-
Combining `writable:false` with `configurable:false` turns an object property into what is essetially an object constant.
 
-Prevent Extensions-
Call Object.preventExtensions(..) to prevent an object from being able to have new properties added to it, while leaving the rest of the object's properties alone.
Attempting to add a property to an object that has extensions prevented will result in a TypeError being thrown in strict mode, otherwise the addition will silently fail.

-Seal-
Object.seal(..) does the same thing as Object.preventExtensions(..) but also sets all existing properties to `configurable:false`, preventing the ability to configure or delete them (although you can still modify their values).

-Freeze-
Object.freeze(..) provides the highest level of immutability for an object, by performing the equivalent of Object.seal(..) upon it, and then additionally setting all 'data accessor' properties as `writable:false` so that their values can't be changed. You cannot change the object or any of its properties. The contents of any referenced objects remain unaffected.
You could recursively iterate through an object's references and call Object.freeze(..) on each of them to "deep freeze" an object, but you have to be careful not to affect other shared objects you weren't attempting to freeze.

-[[Get]]-
When you access a property via dot or bracket notation, you are not just looking for a property of that name in the object. You are actually performing a [[Get]] operation (sort of like a function call) on the object. 
By default, the operation first checks the object for a property of that name, and then returns the value if it is found.
If [[Get]] cannot come up with a value, it instead returns `undefined`. This contrasts variable identifier lookups, which throws a `ReferenceError` instead.

-[[Put]]-
[[Put]] is the operation for setting a property value.
[[Put]]'s behavior is based on whether the property it's trying to assign a value to is already present or not.
If the property is present, [[Put]] will first check if it's an accessor descriptor and call the setter if so. Otherwise, it will check if the property is a data accessor with `writeable:false` and silent error or TypeError based on strict mode settings. If neither of these are applicable, [[Put]] will set the value to the property as usual.
If the property is not present, [[Put]] undergoes an even more complex series of operations.

-Getters & Setters-
The default [[Get]] and [[Put]] operations completely control operations for setting and retrieving property values. They can/may be completely overridden using advanced/future JS capabilities, and partially overridden on a per-property level as of ES5 via the use of getters and setters.
Getters are properties that call a hidden function to retrieve a value, and setters properties that call a hidden function to set a value.
Properties become accessor descriptors (instead of a data descriptor) when they have been defined to have a getter/setter/both. The `value` and `writeable` characteristics are ignored, with JS considering the `get`, `set`, `configurable`, and `enumerable` being availed to accessor descriptors.
You can define a getter property through either object-literal syntax (`get a() {..}' as a property) or explicit definition with Object.defineProperty(..) that, instead of holding a value, will access a hidden getter function that returns a value upon its invocation. Whatever value this function returns will be the result of the property access.
When you only define a getter with a hardcoded return value for a property, you will be unable to reassign its value, instead having it silently thrown away. Because of this, you should also define a setter as well for each accessor descriptor property in order to override the default [[Put]] operation (the act of assignment).

-Existence-
You can see if a property exists without getting its value by using the `in` operator ( `("prop" in myObject)` ). It checks whether the property is "in" the object or at a higher level of the [[Prototype]] chain. It's actually just checking to see if the given property name exists, not for a value itself.
Another way is using the hasOwnProperty(..) object method, which only checks to see if the property exists in the object referenced. It does not check the [[Prototype]] chain.
A method call like `myObject.hasOwnProperty(..)` would fail on an object that does not link to `Object.prototype` via `Object.create(null)`. A more thorough way to check is to use `Object.prototype.hasOwnProperty.call(yourObject, "prop")`, which calls the base `hasOwnProperty(..)` method its `this` value bound to your object.

-Enumeration-
An object property being enumerable essentially means that it will be included if an object's properties are iterated through.
An NON-enumerable object property exists and has an accessible value and will even show via the `in` operator check, it will not show in a `for..in` loop.
Using a `for..in` loop on an array produces both the numeric indices as well as any enumerable properties on the array object. For that reason, it is usually best to use traditional `for` loops on arrays, as they stick to numeric index iteration only, and only using `for..in` loops on objects.
`propertyIsEnumerable(..)` checks if a given property name both exists directly on an object and if that property is `enumerable:true`.
`Object.keys(..)` returns an array containing all enumerable properties located directly on an object.
`Object.getOwnPropertyNames(..)` returns an array containing all properties located directly on an object, regardless of their enumerability.
There is currently no built-in way of iterating through properties on an object up through all levels of the [[Prototype]] chain, in a fashion similar to the way the `in` operator would check an object for a single property, but you can enact such utility by recursively traversing through each [[Prototype]] level in the chain, capturing the `Object.keys(..)`  list each loop, which would pull all enumerable properties from that level.

-Iteration-
When iterating over the values of a numerically-indexed array using a `for` loop, you are iterating over the indices, rather than the values, and then using each index in the loop to reference the value as `yourArray[i]`. Similar applies with iterating on an object using a `for..in` loop, as you are iterating through enumerable properties and then having to manually access properties for values.
ES5 added several iteration helpers for arrays. They are: `forEach(..)`, `every(..)`, and `some(..)`. They all accept a function callback to apply to each array element.
`forEach(..)` iterates over all array values, ignoring any callback return values.
`every(..)` keeps iterating until it reaches the end or until a falsy value is returned by the callback. `some(..)` is the same as `every(..)`, except it will instead end if a truthy value is returned by the callback. These act similar to a `break` statement inside of a normal `for` loop.
Unlike the numerical indices of an array, iterating an object's properties will not necessarily result in consistent ordering, as it may differ between JS engines.
ES6 adds a `for..of` loop for iterating values of array (and objects with custom-defined iterators) directly, with no need to reference the value of the current index in each loop like you would with `for..in`.
`for..of` iterates the return values of a "thing"'s iterator object (derived from a default internal function called `@@iterator`) provided by calling the iterator object's `next()` method each loop until a return of the property characteristic `done:true` is returned.
You can get at the `@@iterator` internal property of an object (either an array object or regular object with a self-defined `@@iterator`) using the ES6 `Symbol` computed property name in the form of `Symbol.iterator`. You'll always want to reference/resolve special properties such as these using `Symbol` instead of the special value they may hold, because the actual value may vary based on JS engine being used. Also keep in mind that `@@iterator` is not the iterator object, but a function that returns said object.
You can create a custom `@@iterator` function for an object using `Object.defineProperty` to define `Symbol.iterator`, ensuring it returns a function value that contains an appropriately-implemented `next()` method that both iterates and returns each value and iteration completion status (`done`) as. You also want to set the enumarable property descriptor characteristic to `enumerable:false`. Another way of doing this is to declare a custom `@@iterator` function directly on the object during its declaration using a key of `[Symbol.iterator]`.
You can define more complex iterators for your custom data structures, which can become quite powerful tools for manipulating user-defined objects when used in combinated with ES6's 'for..of` loop. As long as the iterator returns expected `{ value: .. }` return values from `next()` calls and `{ done: true }` after iteration completes, it will work with the `for..of` loop.
You can generate "infinite" iterators for the sake of always returning a random or incremented value, a unique identifier, etc., although you wouldn't want to use these iterators with an unbounded `for..of` loop, as that would result in a program-hanging infinite loop.

-Review-
Objects come in literal and constructed forms, with literal preferred most of the time and constructed only used in certain circumstances where either additional creation options are needed, or the constructor-only forms are available (such as with the `Date(..)` object).
Objects are only one of the 6/7 primitive types in JS. Objects have sub-types such as `function` and the behavior-specialized `[object Array]'.
Whenever a property is accessed on an object, the engine invokes the internal default `[[Get]]` operation (or `[[Put]]` for setting values), which looks for the property directly on the object, and then traverses up the `[[Prototype]]` chain to search further if not found.
Properties have characterstics which can be accessed through property descriptors, such as `enumerable` and `writable`. Objects can have their (and their properties') mutability set to varying levels of immutability using Object methods such as `Object.preventExtensions(..)`, `Object.freeze(..)`, and `Object.seal(..)`.
Properties can be "accessor properties" rather than "data properties", using getters/setters. They can also be set to `enumerable:false`, which prevents them from showing in enumeration loops such as `for..in`.
You can iterate the values in any given data structure using the ES6 `for..of` loop syntax, which seeks a built-in/custom `@@iterator` object containing a `next()` method to advance through each data value one at a time, and perform additional, custom-defined actions as desired.

===========================================Chapter 4===========================================
Mixing (Up) "Class" Objects

-Class Theory-
OO/class-oriented programming encapsulates behavior and data together, since data always has associated behaviors that operate on it. These are sometimes called data structures in formal computer science. An example of this is the string manipulation methods designed as part of the `String` class. All strings provided are an instance of this class, so both the data and the built-in functionality for manipulating that data are packaged (encapsulated) in the same location.
Classes imply a way of classifying a certain data structure, by categorizing a given structure as a specific variation of a more generalized base definition. For example, a `Car` class inheriting (or extending) from a `Vehicle` class.
Polymorphism is the concept that a child class can override a behavior from its more generalized parent class in order to give it more specifics. Relative polymorphism allows you to reference the base behavior from the overridden behavior.
Class theory strongly pushes using the same method name for both parent and child classes that share a certain behavior, although doing so in JS is apparently not an easy thing to do.

-"Class" Design Pattern-
Procedural programming, used by languages such as FORTRAN and BASIC, only consist of procedures (functions) calling other functions, without any higher abstraction. You can write procedural code in pretty much any language, although you end up with the often-dreaded "spaghetti code".
The use of classes are often recommended as the way to minimize spaghetti code, although with "functional languages" you will find that they are just one of many optional over-arching design patterns.
Some languages, such as Java, limit you to the confines of class-oriented programming, where design patterns are subservient to the class structure.
Other languages, such as C/C++ and PHP, provide both procedural and class-oriented options, giving developers a choice as to the mixture of style they would like to use.

-Javascript "Classes"-
Although the language has some class-like syntactic elements such as `new` and `instanceof` and (as of ES6) includes the `class` keyword, JavaScript does not really have classes.
Since class structure is a design pattern, you can include approximations for most classical class functionality in JS, although the underlying mechanisms function quite differently than what these implementations show on the surface. They are an optional design pattern, and you can either use them in JS or not.

-Class Mechanics-
With a class-oriented language, the standard library typically provides a stack data structure (push, pop, etc.) as a `Stack` class. The class provides you with publicly accessible methods that give your code the ability to interact with the hidden data variables (adding/removing/etc.).
Unless making a `Static` class member reference, you don't truly operate on the stack in such languages. `Stack` is merely an abstract definition of what a stack would do. You still have to instantiate the `Stack` class before you have a concrete data structure "thing" to operate upon.

-Building-
To use the building analogy, a class is the building blueprint. To instantiate that class is to create a physical (constructed) copy of those plans (an object), typically called an instance. It is only this instance (not the class "blueprint" itself) that we can directly call methods and access exposed data properties from.
While an object can't generally directly access and manipulate its class, it's usually possible to determine the class an instantiated object came from.
"A class is instantiated into object form by a copy operation."

-Constructor-
Class instances are constructed by a special method of the class called the constructor, usually having the same name as the class itself. The job of the constructor method is to initialize the instance with any data (state) the instance will need.
Class constructors belong to their classes, and almost always need to be called with the `new` keyword to let the language know you want to construct a new instance of a class.

-Polymorphism-
Relative polymorphism is the concept that a method can reference and inherit from another method, that it is overriding, that exists on a higher level (one level) up the hierarchy without absolutely defining which inheritance level (class) is to be accessed.
In many class-oriented languages, the keyword `super` is used to denote relative inheritance up one level to the parent class. It's also useful with real classes because you can reference the constructor of a parent class from the constructor of a child class. This works because the constructor "belongs" to its containing class.
The same does not apply in JS, as the "class" moreso belongs to the constructor. The parent/child relationship only exists between the `.prototype` objects of their respective constructor objects, the constructors are not directly related themselves (although ES6's `class` attempts to solve this with `super`).
In class-oriented languages, if you have a class that inherits a function using `super` relative inheritance, and that function references another member that exists on both child and parent class, the language engine will reference the function on the child class. If the child class instantiated the parent class as an object and then called that function, the engine would use the parent classes' function definition. The definition for the referenced method "polymorphs" (changes) based on which class (level of inheritance) you're referencing an instance of.
A child class is only given a copy of the inherited behavior from its parent class. This means that if a child overrides a method it inherits, both the original parent overridden versions of the method are preserved. Polymorphism does not imply the linking of classes. Class inheritance implies copies.

-Multiple Inheritance-
Multiple inheritance means that multiple parent class definitions are copied into a child class.
Problems can arise with such usage, some pertaining to the potential of inheriting multiple members of the same type and name.
JavaScript does not include a native mechanism for multiple inheritance, although developers have faked such functionality in various ways.

-Mixins-
In JavaScript, there are no "classes", and there is no automatic copy behavior when one "inherits" or "instantiates". There are only objects, and rather than copy objects to other objects, they are instead linked together.
Javascript developers fake this copying class behavior via the use of mixins.
There are two types of mixins: Explicit and implicit.

-Explicit Mixins-
Since JS doesn't automatically copy behavior from one object to another, you can create and use a utility to manually copy the properties over. This is a mixin, but is often referred to in code as an `extend(..)` method by many libraries and frameworks.
The mixin utility essentially iterates each key from the source object, checks to make sure it doesn't already exist in the target object (skipping over if it does), and adds each property to the target object.
Function references, rather than the functions themselves, are actually copied to the target object when mixing in a source object.

-"Polymorphism" Revisited-
Since there is no relative polymorphism in JS (prior to ES6), instead you must make an absolute (rather than relative) reference that specifies both the object and function by name. An example is `ParentObject.function.call( this ). This ensures the function call is bound to and executed from the context of the child object you are calling from. You could call this "explicit pseudo-polymorphism".
You have to use this more explicit pseudo-polymorphism when your `mixin(..)`/`extend(..)` call does not copy over a property/function reference due to the property/function name identifier of the parent/source object overlapping ("shadowing") with one in the child/target object.
In class-oriented languages with relative polymorphism, class linkage is established one time at the top of the class definition. In JavaScript, this pseudo-polymorphic linkage has to be explicitly implied for every function reference with identifier overlap shadow. This manual/explicit linkage is brittle in comparison to it's class-oriented counterpart.
Explicit pseudo-polymorphism can also emulate multiple inheritance, but this only increases the brittleness and complexity of your objects.
According to the author, explicit pseudo-polymorphism should be avoided whenever possible.

-Mixing Copies-
Manually copying functions (using mixins) in JS still does not actually emulate the real duplication of a class to an instance that would occur in class-oriented languages. You can only duplicate a function reference. If you modify a shared function object, for example by adding properties to it, any objects that share the duplicated reference would be affected.
Not much benefit is derived from copying properties from one object to another versus just defining the properties twice, once on each object (especially when function-object references are made).
There is also no way to handle multiple inheritence method/property collisions, although some libraries have devised a "late binding" technique, among other workarounds. According to the author, they tend to require more effort and less performance than you are actually getting from the payoff.
Try to only use explicit mixins when it helps make your code more readable. Avoid it where it makes code harder to trace and dependencies between objects overcomplicated. There are better ways to accomplish these desired outcomes, to be outlined.

-Parasitic Inheritance-
Parasitic inheritance is a variation of the explicit mixin that makes a copy of the definition from the "parent" object and then mixins your "child class" object, saving a privileged parent reference to any properties to be overridden, and then returning the composed object as your child instance (object).
No need to use the `new` keyword when creating an instance, since running the child function already returns a new copy of that object. You'd just be creating additional object waste for garbage collection.

-Implicit Mixins-
Implicit mixins are similar to explicit pseudo-polymorphism in that they should be avoided due to the same pitfalls. You basically call an assignment function from one object property within a property function of another object, being sure to bind it to the "child" context using `call( this )`. All of the assignments from the original function are now applied against the object you are currently invoking it from, essentially mixing the behaviors of one object into another.
Implicit mixins cannot be made into a relative reference, so avoid when possible.

-Review-
JS has a similar syntax to languages with a natural class-oriented software design pattern, but behaves very differently.
"Classes mean copies."
Class instantiation = Copying behavior from class to instance.
Polymorphism (different functions at multiple levels of the inheritance chain with same name) is just a result of copy behavior.
JavaScript doesn't automatically create copies between objects. The mixin pattern sort of emulates this copy behavior, but often leads to complex and brittle code like that of explicit pseudo-polymorphism. Objects and functions are not copied and only have duplicated references that point to the same location.
Faking classes bad. Don't be bad.

===========================================Chapter 5===========================================
Prototypes

All attempts to emulate class/instance copying behavior (mixins) completely circumvent the [[Prototype]] chain mechanism.

-[[Prototype]]-
Objects in JS have an internal property known as [[Prototype]], which is a reference to another object. Nearly all objects are assigned a non-null value for this property when they are created.
`Object.create(..)` creates a new object that is [[Prototype]] linked to the object you pass. If you run a [Get] operation on this new object for a property that has not been defined on it, [Get] will traverse one level up the [[Prototype]] chain in search of a match, and will continue to do so until it reaches the end of the chain. If a match is not found, the return result will be `undefined`.
Similar applies for the `for..in` loop, which will iterate an object for any enumerable property in an object's chain.
Using the `in` operator checks for the existence of a property on an object and its entire chain as well, regardless of enumerability.

-Object.prototype-
All normal, built-in JS objects have the `Object.prototype` object at the top of their [[Prototype]] chain.
This object contains many utilities such as `.toString()`, `valueOf()`, `.hasOwnProperty()`, and `.isPrototypeOf()`.

-Setting & Shadowing Properties-
If you assign a value to a property of an object and that property does not exist, [[Put]] will traverse the [[Prototype]] chain in search of a matching property. If one is not found, the property will be created on the initially specified object and assigned the value. If one is found, one of three things can happen.
	1. If a normal data accessor that is found up the chain is set to `writable:true`, then the property you specified is added directly to your initial object, resulting in a "shadowed" property.
	2. If a matching property is discovered up the chain and set to `writable:false`, both the setting of the existing property and the creation of the new property on your initial object will be disallowed, with an error being thrown in strict mode or being silently ignored otherwise. No "shadowing" occurs.
	3. If the discovered property is a setter, the setter will always be called. Nothing will be added to your initial object, and the setter will not be redefined.
To add a property that shadows another up the chain in situations 2 or 3, you must use `Object.defineProperty(..)`, rather than the assignment operator.
If the property exists on both the initial object itself and at a higher level of the [[Prototype]] chain, this is called "shadowing", as the property on the initial object now "shadows" any matching properties higher up.
The inability to create a property on an object that is read-only further up the [[Prototype]] chain was put in place to enforce the illusion of class-inherited properties. It doesn't make the most sense, seeing as no inheritance copying is actually occurring.
Shadowing with methods leads to explicit pseudo-polymorphism. Shadowing should be avoided whenever possible. A superior design pattern will be outlined in Ch6.
Implicit shadowing can even occur if you, for example, use the `Object.create(..)` method and then increment the value of a property on the newly-created object that previously only existed on your higher-level [[Prototype]] chain object, as this would implicitly create a new property with the modified value that now shadows your higher-level property. The only correct way increment the higher-level property value in this example would be to explicitly name that high-level object as the one to be incremented.

-"Class"-
JS is one of very few languages where objects can be created directly, without a class (because they don't exist).
Since classes can't define what objects do, the object defines its own behavior directly.

-"Class" Functions-
All functions get a public, non-enumerable property on them called `prototype` by default, which points to an arbitrary object. Every object created from calling `new myObj()` will be [[Prototype]]-linked to the object that `myObj.prototype` is pointing at.
This still does no inheritance copying. It simply links two objects together in an indirect manner.

-What's in a name?-
The mechanism of linking objects together is referred to as "prototypal inheritance", which is said to be the dynamic language version of "classical inheritance", where one object (class) is copied to another (instance). Author opines that this label is not good, as this conflates one with the other, when in fact the underlying mechanisms are entirely different, regardless of all of the attempts mis-apply all of the class-oriented terminology to the JS language.
Inheritance implies a copy operation. JS does not natively do such a thing. Delegation is a more accurate term to use, seeing as JS creates can create links between objects, where one object can delegate both property and function access to another.
Another term sometimes used is "differential inheritance", which is the idea that an object describes its behavior in terms of differences from a general descriptor, rather than re-describing all of the details of the more generalized thing along with the differences. This still makes the mistake of implying "inheritance" and also does not take into account the fact that objects are simply described without certain details, and that these omissions are to be handled via delegation.

-"Constructors"-
It's easy to think of a function as a class being instantiated when you assign a class using the `new` keyword, just like when a class-oriented language constructs a new class instance. The function is called similarly to how a class constructor would be called. The function's `.prototype` object also gets a non-enumerable property called `.constructor` on creation by default, which references back to the function the object is associated with.
The object created by this "constructor" call seems to have the same `.constructor` property on it that points to the same function, but this property does not really exist on the object.
By common convention in JS, functions are named with a capital letter when they are intended to be "classes". Many JS linters actually alert you if you call `new` on a function with a lowercase name.

-Constructor Or Call?-
Functions themselves are not "constructors". When you put a `new` keyword in front of one, that makes the function call a "constructor call". `new` calls a function in a way that constructs an object, in additional to whatever else the function call does.
You could say a "constructor" in JS is any function with a `new` keyword in front of it.

-Mechanics-
`this.prop = prop` in a function that is passed a `prop` will add that property to each object created using that function with the `new` keyword, similar to the way class instances encapsulate data values.
`myObject.prototype.myProp = ..` adds a property to an object's prototype object.
Properties/functions on an object's `.prototype` are not copied when `new` objects are created from that original object. They instead are created with an internal [[Prototype]] linkage to the initial object's `.prototype` object, so if a property is referenced on one of the newly created objects, [[Get]] or [[Put]] will follow the same [[Prototype]] chain check as usual, following the same set of rules outlined previously, based on its findings.

-"Constructor" Redux-
The `.constructor` property that appears to exist on a `new` function object is actually a reference that is delegated up to the object's `.prototype`, which contains a `.constructor` property pointing to object your `new` object was "constructed by".
There are numerous pitfalls to relying on `.constructor` the way you would with a true constructor in a class-oriented language. If you create a new object where the originating object had its `.prototype` object reference changed, the new object will not by default have a `.constructor` to reference in the originating object. With [[Prototype]] chain traversal rules, `.constructor` would end up being referenced in `Object`.

-Misconception, busted-
You can add `.constructor` back to your originating object's `.prototype` manually, but you have to be careful to match its native behavior and non-enumerability.
This still perpetuates the illusion that a "constructor" means "constructed by" in JS.
`.constructor` is extremely unreliable and untrustworthy due to its mutability and the underlying delegatory mechanics of JS. Avoid referencing it when possible.

-"(Prototypal) Inheritance"-
To create a semblance of "inheritance" between two classes, you can assign the object `.prototype` of one class to be equal to the `Object.create(..)` of your other object's `.prototype`. This creates a new object for the initial `.prototype` and links its internal [[Prototype]] to the `.prototype` of your other object.
`Bar.prototype = Foo.prototype` would assign a reference of `Foo.prototype` to `Bar.prototype`, rather than create a new object that is linked to `Foo.prototype`. That means if you modified or added properties on `Bar.prototype`, you would actually be altering the contents of `Foo.prototype`.
`Bar.prototype = Foo()` creates a new object does create a new object that links `Bar.prototype` to `Foo.prototype`, but produces the unintended side effects of also running any additional code in `Foo()` at the time of linking, rather than only when descendants of Bar() are created, which was the likely intention for the execution of that code.
A downside to using `Object.create(..)` to link the prototypes of two "class" objects is that you have to create `.prototype` object, having to throw the old one away. There is both a (not fully cross-browser compatible) pre-ES6 way and a standardized ES6 way to modify the linkage of an existing object.
While `Object.create(..)' is the preferrable way to handle object prototype linking pre-ES6, some use the non-cross-browser compatible `.__proto__` property, which is settable.
ES6 adds the `Object.setPrototypeOf(..)` helper method, which takes your target and source prototype objects as respective parameters, doing what `Object.create(..)` accomplishes via modification of the target object, rather than replacement.

-Inspecting "Class" Relationships-
Inspecting an "instance" (an object) for its "inheritance ancestry" (delegation linkage) is often called "introspection" or "reflection" in class-oriented environments.
There are multiple ways to introspect/reflect an "instance"/object to find its "ancestry"/delegation linkage.
The `instanceof` operator takes an object as its left-hand operand and a function object on the right. `instanceof` checks if the object pointed to by the `.prototype` of the right-hand function object ever appears in the [[Prototype]] chain of the left-hand object. This means `instanceof` can only work if you have a function with a `.prototype` reference to test with and that you could not check if one plain object was an "ancestor" of another plain object.
If you make a hard-bound function using `bind(..)`, it will not be created with a `.prototype` property. Using `instanceof` on such a function would result in the `this` function your function is bound to having its `.prototype` being substituted in for the operation. This makes sense because you would again invoke the original function if you were to use a hard-bound function as a "constructor call".
It is actually possible to examine the relationship between two plain objects with `instanceof`, but you have to assign your "parent" object to an empty throw-away function's `.prototype` before using it as your right-hand operand. This just further points out the awkwardness of "class" semantics in JavaScript.
The cleaner approach to [[Prototype]] reflection is to use the `.isPrototypeOf(..)` helper utility of `.prototype`. `.isPrototypeOf(..)` checks to see if in the entire [[Prototype]] chain of the passed object argument, does `MyObject.prototype' ever appear? Exactly the same as `instanceof`, but without the need to indirectly reference a function whose `.prototype` reassigned to the object whose [[Prototype]] chain you want to check.
As of ES5, you can also directly retrieve the [[Prototype]] of an object by using `Object.getPrototypeOf(..)`.
The previously mentioned `.__proto__` retrieves the internal [[Prototype]] of an object as a reference, which can be useful for inspecting, comparing, or traversing (`.__proto__.__proto__`) its chain. This wasn't standardized until ES6, so doesn't have support from every browser.
`.__proto__` (verbally known as "dunder proto") is not located on the object itself, but is actually built into `Object.prototype' as a non-enumerable property (it's more akin to a getter/setter).
Although you shouldn't generally change the [[Prototype]] of an existing object, you can do so using `.__proto__`, which is settable in a fashion similar to `Object.setPrototypeOf(..)`. It can come in handy if you are in a situation where you want to change a default function's `.prototype` to some other object than `Object.prototype` without replacing/discarding the object in place.

-Object Links: `Create()`ing Links-
Assigning `Object.create(..)` to a new object without using the `new` keyword simply links the new object to the passed one, giving you the delegation power of the [[Prototype]] chain without any of the additional "class"-related complication.
`Object.create(null)` creates an object with an empty [[Prototype]] linkage. The `instanceof` operator will always return `false`, as there is nothing to check. These special empty [[Prototype]] objects are usually called "dictionaries", used purely for the flat storage of data.

-`Object.create()` Polyfilled-
`Object.create(..)` will need to be polyfilled in pre-ES5 environments (like older IE). You can partially accomplish this by using an empty throwaway function, pointing its `.prototype` to the object you want to link to, then using `new` "construction" to create a new object that will possess the specified linkage. You will not be able to add the functionality of declaring property descriptors for each new property on a newly declared object pre-ES5, which is why this is only a partial polyfill.
Some developers do not condone the use of partial polyfills, and recommend that necessary partial polyfills be written as entirely separate utilities. The author does not agree with this sentiment.

-Links As Fallbacks?-
Author states that while there are some occasions where intentionally using links as fallbacks for properties that may not exist on a lower object down the chain, you should avoid this when possible, as it can make the code more difficult to comprehend and maintain.
The appropriate way to make code more readable while still taking advantage of the [[Prototype]] chain (for example, with an API where you don't want to directly expose some functionality) is to follow the "delegation design pattern", which is to instead implement an explicit method for each perceived endpoint, and then have those methods reference the properties/functions higher up the chain using internal delegation.

-Review-
Cascading [[Prototype]] linkage between objects is somewhat similar to a nested scope chain, but consists of objects for a [[Get]] operation to traverse for property resolution.
Normal objects have `Object.prototype` at the top of their [[Prototype]] chain, similar to global scope in a scope lookup. Several common utilities exist on `Object.prototype` as well, which is why all objects in JS can access them.
The most common way to link two objects to one another is with the `new` keyword, which creates a new object linked to the other. The "another object" that the new object is linked to is the one referenced by the `.prototype` property of the function called by `new`. These functions are often called "constructors", although they are not instantiating/constructing a class. No copies are natively made with these "class instantiation/inheritance" mechanisms in JavaScript, only linked to one another in an internal [[Prototype]] chain.
"Delegation" is the most appropriate term for the way objects relate to one another, as they are not copies of one another but rather delegation links.

===========================================Chapter 6===========================================
Behavior Delegation

Most JS developers resign to using some sort of class library, rather than getting a full grasp of the [[Prototype]] chain and related design patterns.
Each object contains its own [[Prototype]], and when a property/method is referenced on that object that does not exist, [[Get]] traverses up the chain to the object referenced in [[Prototype]], runs the check again for the property/method, traverses up that object's [[Prototype]], and repeats until a match is found or `Object.prototype` is reached (sort of like the "global" of the [[Prototype]] chain).

-Towards Delegation-Oriented Design: Class Theory-
If you have a set of similar tasks that you need to model in your software and you are using classes, you would define a base (general) class where you would define shared behavior for all alike tasks. Then, you would define your child classes, each of which would inherit from your base class before adding on their own specialized behaviors.
The class design pattern encourages one to employ method overriding (and polymorphism) to get the most out of inheritance. Perhaps you'll use `super` to call the base version of a method in order to add more behaviors onto it. You will often find places where you can "abstract" (out) general behavior to your base/parent class and then override it in your child classes where necessary.
Equipped with classes, you can now instantiate your child classes, which will create a copy of them whenever performed, along with their own set of data that the child class and any inherited classes contain.

-Delegation Theory-
With behavior delegation, you first define a Task object (rather than a class, or even a function) containing concrete behaviors and utility methods that other tasks can delegate to. For each task, you define another object to hold it and any task-specific data. You then link those objects to your Task utility object, which allows them the ability to delegate to it when needed.
You can think of this as performing a specific task using two sibling/peer objects, but rather than composing them together as a copy, the objects remain separate, with the specific task object delegating to the generalized Task object when needed via linkage.
The author calls this style of code "OLOO" (objects-linked-to-other-objects).
With OLOO and [[Prototype]] delegation, you generally want state to be on your delegators ("children"/utilizer), not on the delegate ("parent"/utilized).
In the class design pattern, you will often take advantage of overrides/polymorphism by giving a child property the same name as a property on the parent. With behavior delegation, you want to avoid the same names on different levels of the same [[Prototype]] chain whenever possible (it's called `shadowing` when it occurs). When you shadow, you create the necessity of using brittle syntax on individual properties to disambiguate your references. Use more descriptive, self-documenting naming conventions for your methods that are specific to the type of behavior they are performing.
With [[Prototype]] delegation, calling a method bound to `this` that is only present a level up on the chain will result in the method being called while being implicitly bound to the originating call-site.

-Mutual Delegation (Disallowed)-
You will get an error if you attempt to link two objects to each other, as referencing a property/method that didn't exist on either objects would cause an infinite recursion on the [[Prototype]] loop.
While it would have had its uses in an environment that checked for the infinite circular reference, engine implementors decided it worth the increase in performance to do a single error check at set-time for mutual delegation.

-Debugged-
JS spec does not control how browser dev tools should display certain values/structures to the developer. Because of that, they don't always see eye to eye.
For example, in Chrome Developer Tools, when evaluating an expression that was assigned an empty function object, you get an empty object belonging to the empty function object you referenced in your assignment. With Firefox, the same evaluation would result in `Object {}`. Chrome's output is showing you that you have an empty object that was constructed by that particular function. Firefox is saying you have an empty object of general construction from `Object`. The difference is that Chrome is tracking the name of the function that did the construction as an internal property, whereas other browsers do not track this.
Chrome appears to be using the initially set `prototype.constructor` property to track this, (buggily) updating the value only if you use `Object.defineProperty` to update it. You won't get this internal tracking extension if you don't use a "constructor" when making your objects, which the author discourages anyways when using OLOO-style code, and would instead see `Object {}` as the source of construction.
With the behavior delegation design pattern, who "constructed" your object is of no relevance, and is only relevant if you are embracing "class-style" coding.

-Mental Models Compared-
Even between the two varying styles (classical "prototypal" OO-style and OLOO-style), you would still have the same objects linked together via [[Prototype]] delegation, but with behavior delegation style you would avoid the need to use "class"-style trimmings such as constructors, `.prototype`, and `new` keyword calls.
With OLOO-style coding, you stick to what matters, which is linking objects to other objects.

-Classes vs. Objects: Widget "Classes"-
With OO design patterns you are intended to declare base classes, override them with your child classes, and then augment that base functionality with those overrides.
To do this in JS you use `.call` in your child objects to make a "super" call back up to your parent class, which results in the expected class-style explicit pseudo-polymorphic clutter.

-ES6 `class` Sugar-
Much of the ugly syntax of the pre-ES6 class-oriented approach is cleaned up with the use of ES6's `class` keyword functionality, especially the `super(..)` method.
Of course, these are still not real classes we're working with here.

-Delegating Widget Objects-
When using OLOO-style delegation, you want to avoid sharing method names with delegates, so for an example of initialization methods, you want to use separate and descriptive terms like `init(..)` and `setup(..)` on linked objects. This helps avoid using the explicit pseudo-polymorphic `.call`s and its ES6 `super` counterpart. You simply use delegated `this.prop(..)` calls from your delegator.
With "class" constructor syntax, you are coerced into doing both construction and initialization in the same call (assigning your "class" function call), whereas OLOO allows for easier seperation of the two by assigning an `Object.create` to a new object and then calling your initialization method.

-Simpler Design-
With class-style syntax, you would typically add base functionality into a `Controller` class, with more task-specific controller sub-classes inheriting from it.
If one child controller needs to know about another, you can instantiate it as a passed argument and create a class member property to reference it, being able to invoke behaviors on that passed class from the other. This is called "composition", which in OO is basically the act of combining classes together.
"Virtual composition" is inheriting one subclass from another. It is discouraged when neither class is a specialization of the other in regards to base behaviors. Inheritance doesn't make sense unless classes are the only design pattern available to you.
