===========================================Chapter 1===========================================
'this' Or That?

-Why this?-
The 'this' keyword allows functions to be reused against multi-context objects, instead of needing a separate function for each object.
The 'this' mechanism provides an elegant way to implicitly pass an object reference, which leads to cleaner and more reusable API design. Passing along parameters in increasingly complex usage patterns becomes cumbersome and messier than simply passing things through the 'this' context.

-Confusions: Itself-
'this' does not refer to or root in the enclosing function itself.
You can add a property to a function but using 'this' to access a property of the same name will not necessarily refer to that function object.
Devs who fail to understand the 'this' keyword often fall back onto lexical scope at this point and just create a new object.
If you need to access a function's object, you can use a named function and refer to it using its identifier.
Do not use anonymous functions if they will be referring to themselves. There is an arguments.callee reference that was used in anonymous functions, but it is now deprecated. Use a named function expression instead.
To use 'this' in such a situation, you would force 'this' to point to the function object using the call() method on the function, which executes the function while allowing you to provide a value to 'this' (in this case, the function you want to refer to).

-Confusions: Its Scope-
'this' does not in any way refer to a functions lexical scope. While internally, scope is sort of like an object with properties of each available identifier, this is only accessible to the JS engine itself, and not the code.
You cannot bridge two scopes together by invoking one from the other leading with the 'this' keyword.

-What's this?-
'this' is a run-time binding, rather than an author-time binding. It has everything to do with how a function is called.
When you invoke a function, an activation record (or execution context) is created. It contains info on where the function was called from (the call-stack), how it was invoked, what parameters were passed, etc. One of the properties of this record is the 'this' reference that will be used for the duration of that function's execution.
Finding a function's call-site will determine how its execution will bind 'this'.

===========================================Chapter 2===========================================
'this' All Makes Sense Now!

-Call-site-
The call-stack is essentially the chain of functions called in order to get to whatever location your code is currently at in execution.
The call-site is the location (function or global) in which the function you have currently stepped into was invoked.
You can use a JS debugger in your browser by setting a breakpoint at the beginning of a function or insert a 'debugger;' statement in the same location to cause the debugger to pause and show you the call-site/stack for each invocation of that function when the code is executed.

-Nothing But Rules: Default Binding-
Variables declared in global scope are synonymous with global-object properties of the same name.
The default binding applies to the function call, so if the function was called from global, then 'this' would point to the global object.
When a function is called with a plain, undecorated function reference, default binding is the only type that would apply.
In strict mode, the global object is not eligible for default binding. 'this' would be set to undefined in a function with a global call-site. This would only apply if your function contents were set to strict mode. The state of the call-site is irrelevant.
Author opines that you should not mix non-strict with strict mode, although sometimes this is unavoidable due to the inclusion of third-party libraries.

-Implicit Binding-
If the call-site has a context object (an object reference precedes the function call), you could say the context 'owns' or 'contains' the function reference at the time the function is called.
The implicit binding rule demands that the context object is what should be used for the function call's 'this' binding.
'this.a' would be synonymous with 'obj.a'
Only the last or top level of the object reference property chain matters to the call-site when determining what should be used for the 'this' binding.

-Implicitly Lost-
If you create a new reference to the previous function call that is preceded by an object reference and then call that reference in a plain, undecorated fashion, default binding rules will apply. This is because the new reference is really just another reference to the function call itself. The call-site is what matters, so if it's simply a global, undecorated function call, you would have a value of global or undefined bound to that function's 'this' value, depending on your strict mode settings.
The same rule applies when passing a callback function. The preceding object reference in the passed function is essentially stripped out. Parameter passing is just an implicit assignment, so passing a function is an implicit reference assignment.
Another way 'this' can be of surprise is when functions you've passed your callback to intentionally change the 'this' reference for the call. Event handlers in popular JS libraries will frequently force your callback to have a 'this' which points to something such as the DOM element that triggered the event.

-Explicit Binding-
Explicit binding allows you to force a function call to use a specific object for the 'this' binding without putting a property reference on the object, like you would do with implicit binding.
The vast majority of functions have some utilities made available to them via their [[Prototype]] that can be useful for this, specifically the call(..) and apply(..) methods. Both of these methods take an object to use for 'this' as their first parameter, and then invoke it using the specified 'this'. This is an example of explicit binding.
If you pass a primitive value of type 'string', 'boolean', or 'number' as the 'this' binding, the primitive value is wrapped in its object form (new String(..), new Boolean(..), etc). This is commonly referred to as "boxing".
'call' and 'apply' are identical in respect to 'this' binding, although they do behave differently with their additional parameters.

-Hard Binding-
Explicit binding alone does not address the previous issue of a function losing its intended 'this' binding, being superceded by a framework, etc, but the hard binding variation of explicit binding does take care of this.
To hard bind, you create a function that forcibly invokes your target function using the call(..) or apply(..) method, explicitly binding its 'this' keyword to the object you specify. No matter how you later invoke the containing function, it will always manually invoke your target function with the object you specified bound to 'this'. This is called hard binding, which is both explicit and robust.
The most common way to wrap a function with a hard binding is to use the apply method to create a pass-thru of any received value: (apply( obj, arguments ))
Another way to express the hard binding pattern is to create a re-usable helper. This helper function would take both the function to be bound and the object to bind as parameters and would return a function that would bind them together and pass any additional arguments provided using the apply method. You'd then assign this bind function to a var and pass any of your additional arguments when you call that function.
This feature is actually a built-in method in ES5 as bind(..), which returns a new function that is hard-coded to call the original function using whatever object parameter you passed as the 'this' context.
In ES6, any function produced by the bind(..) method should have a .name property that provides you the original target function. For example, `bar = foo.bind` would result in bar.name giving a value of "bound foo".
