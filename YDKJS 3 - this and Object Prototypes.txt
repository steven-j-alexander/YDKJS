===========================================Chapter 1===========================================
'this' Or That?

-Why this?-
The 'this' keyword allows functions to be reused against multi-context objects, instead of needing a separate function for each object.
The 'this' mechanism provides an elegant way to implicitly pass an object reference, which leads to cleaner and more reusable API design. Passing along parameters in increasingly complex usage patterns becomes cumbersome and messier than simply passing things through the 'this' context.

-Confusions: Itself-
'this' does not refer to or root in the enclosing function itself.
You can add a property to a function but using 'this' to access a property of the same name will not necessarily refer to that function object.
Devs who fail to understand the 'this' keyword often fall back onto lexical scope at this point and just create a new object.
If you need to access a function's object, you can use a named function and refer to it using its identifier.
Do not use anonymous functions if they will be referring to themselves. There is an arguments.callee reference that was used in anonymous functions, but it is now deprecated. Use a named function expression instead.
To use 'this' in such a situation, you would force 'this' to point to the function object using the call() method on the function, which executes the function while allowing you to provide a value to 'this' (in this case, the function you want to refer to).

-Confusions: Its Scope-
'this' does not in any way refer to a functions lexical scope. While internally, scope is sort of like an object with properties of each available identifier, this is only accessible to the JS engine itself, and not the code.
You cannot bridge two scopes together by invoking one from the other leading with the 'this' keyword.

-What's this?-
'this' is a run-time binding, rather than an author-time binding. It has everything to do with how a function is called.
When you invoke a function, an activation record (or execution context) is created. It contains info on where the function was called from (the call-stack), how it was invoked, what parameters were passed, etc. One of the properties of this record is the 'this' reference that will be used for the duration of that function's execution.
Finding a function's call-site will determine how its execution will bind 'this'.

===========================================Chapter 2===========================================
'this' All Makes Sense Now!

-Call-site-
The call-stack is essentially the chain of functions called in order to get to whatever location your code is currently at in execution.
The call-site is the location (function or global) in which the function you have currently stepped into was invoked.
You can use a JS debugger in your browser by setting a breakpoint at the beginning of a function or insert a 'debugger;' statement in the same location to cause the debugger to pause and show you the call-site/stack for each invocation of that function when the code is executed.

-Nothing But Rules: Default Binding-
Variables declared in global scope are synonymous with global-object properties of the same name.
The default binding applies to the function call, so if the function was called from global, then 'this' would point to the global object.
When a function is called with a plain, undecorated function reference, default binding is the only type that would apply.
In strict mode, the global object is not eligible for default binding. 'this' would be set to undefined in a function with a global call-site. This would only apply if your function contents were set to strict mode. The state of the call-site is irrelevant.
Author opines that you should not mix non-strict with strict mode, although sometimes this is unavoidable due to the inclusion of third-party libraries.

-Implicit Binding-
If the call-site has a context object (an object reference precedes the function call), you could say the context 'owns' or 'contains' the function reference at the time the function is called.
The implicit binding rule demands that the context object is what should be used for the function call's 'this' binding.
'this.a' would be synonymous with 'obj.a'
Only the last or top level of the object reference property chain matters to the call-site when determining what should be used for the 'this' binding.

-Implicitly Lost-
If you create a new reference to the previous function call that is preceded by an object reference and then call that reference in a plain, undecorated fashion, default binding rules will apply. This is because the new reference is really just another reference to the function call itself. The call-site is what matters, so if it's simply a global, undecorated function call, you would have a value of global or undefined bound to that function's 'this' value, depending on your strict mode settings.
The same rule applies when passing a callback function. The preceding object reference in the passed function is essentially stripped out. Parameter passing is just an implicit assignment, so passing a function is an implicit reference assignment.
Another way 'this' can be of surprise is when functions you've passed your callback to intentionally change the 'this' reference for the call. Event handlers in popular JS libraries will frequently force your callback to have a 'this' which points to something such as the DOM element that triggered the event.

-Explicit Binding-
Explicit binding allows you to force a function call to use a specific object for the 'this' binding without putting a property reference on the object, like you would do with implicit binding.
The vast majority of functions have some utilities made available to them via their [[Prototype]] that can be useful for this, specifically the call(..) and apply(..) methods. Both of these methods take an object to use for 'this' as their first parameter, and then invoke it using the specified 'this'. This is an example of explicit binding.
If you pass a primitive value of type 'string', 'boolean', or 'number' as the 'this' binding, the primitive value is wrapped in its object form (new String(..), new Boolean(..), etc). This is commonly referred to as "boxing".
'call' and 'apply' are identical in respect to 'this' binding, although they do behave differently with their additional parameters.

-Hard Binding-
Explicit binding alone does not address the previous issue of a function losing its intended 'this' binding, being superceded by a framework, etc, but the hard binding variation of explicit binding does take care of this.
To hard bind, you create a function that forcibly invokes your target function using the call(..) or apply(..) method, explicitly binding its 'this' keyword to the object you specify. No matter how you later invoke the containing function, it will always manually invoke your target function with the object you specified bound to 'this'. This is called hard binding, which is both explicit and robust.
The most common way to wrap a function with a hard binding is to use the apply method to create a pass-thru of any received value: (apply( obj, arguments ))
Another way to express the hard binding pattern is to create a re-usable helper. This helper function would take both the function to be bound and the object to bind as parameters and would return a function that would bind them together and pass any additional arguments provided using the apply method. You'd then assign this bind function to a var and pass any of your additional arguments when you call that function.
This feature is actually a built-in method in ES5 as bind(..), which returns a new function that is hard-coded to call the original function using whatever object parameter you passed as the 'this' context.
In ES6, any function produced by the bind(..) method should have a .name property that provides you the original target function. For example, `bar = foo.bind` would result in bar.name giving a value of "bound foo".

-API Call "Contexts"-
Many library functions and new built-in JS functions provide a parameter, usually called "context", that is designed as a work-around to using bind(..).
Internally, these functions most likely use call(..) or apply(..) to explicitly bind behind the scenes to ensure a callback function uses a specified 'this'.

-'new' Binding-
The code pattern to use the 'new' operator in JS looks pretty much identical to the way it would be used in a class-oriented language, which would call the constructor for a newly instantiated class. However, JS does not have any connection to class-oriented functionality when using 'new'.
In JS, a constructor is basically just a function that is called with a 'new' operator in front of it. They are not attached to nor do they instantiate a class. They are regular functions that are hijacked by the use of 'new' in their invocation.
Pretty much any function, including built-in ones such as Number(..) can be called with 'new' in front of it, and that makes the function call a constructor call. There is no such thing as a constructor function, only a constructor call of a function.
When you invoke a function with new in front of it, also known as invoking a constructor call: 
	1. A brand new object is created (constructed), initialized by the function you called. 
	2. The newly-constructed object is [[Prototype]]-linked. 
	3. The newly-constructed object is set as the 'this' binding for that function call. 
	4. Unless the function returns its own alternate object, the 'new'-invoked function call will automatically return the newly-constructed object.
'new' is the final way that a function's 'this' can be bound, hence the name of 'new' binding'.

-Everything In Order-
When dealing with a situation where multiple rules are applied, default binding is the lowest-priority rule of the four bindings.
Explicit binding always takes precedence over implicit binding.
'new' binding is more precedent than implicit binding.
'new' and call/apply cannot be used together, but you can use hard binding to (less directly) test explicit binding against 'new' binding.
Recall that hard binding uses Function.prototype.bind(..) to create a new wrapper function that eschews its own 'this' binding in exchange for one that is manually provided.
The prototype bind(..) function has code built into it that gives 'new' binding more precedence over explicit binding. This is useful because you can still use the capability of bind(..) to pass arguments after the first 'this'-binding argument that will then be defaulted as standard arguments to the underlying function, while ignoring the 'this' hard-binding. This technique is called "partial application", which is a subset of "currying".

-Determining 'this'-
1. Is the function called with the 'new'? If so, 'this' is the newly constructed object (new binding).
2. Is the function called with the 'call' or 'apply' methods, or hidden inside a 'bind' hard binding? If so, 'this' is an explicitly specified object (explicit binding).
3. Is the function called with a context, otherwise known as an owning or containing (or preceding) object? If so, 'this' is that context object (implicit binding).
4. Otherwise, default the 'this'. If in strict mode, it will be undefined. If in non-strict mode, 'this' will be the global object.

-Binding Exceptions: Ignored 'this'-
There are some exceptions to the above rules that will result with the default binding rule being applied unexpectedly.
If you pass null or undefined as a 'this' binding parameter to the call/apply/bind methods, those values will be ignored and default binding rules will apply. This is sometimes used as the apply method is commonly used to spread out arrays of values as parameters to a function call. bind(..) can also curry out values as parameters in a similar fashion. 'null' works as a placeholder value in these applications where changing the 'this' binding is inconsequential.
ES6 now uses the spread operator '...' which allow you to syntactically spread out an array as parameters without the need for the more generalized apply(..) method. There is still no ES6 substitute for currying with the bind(..) method, so this still needs to be kept in mind.
The downside to passing null to these methods as a 'this' binding is that if it gets passed to a function (for example a third-party library function that you don't understand or is subject to change) and it does make a 'this' reference, the default binding rule means it may inadvertently reference (or even mutate) the global object (which is window in the browser).

-Safer 'this'-
A better alternative to passing 'null' as a this binding in scenarios that require these methods is to instead create an empty, non-delegated, placeholder object and pass that, circumventing any potential problematic side-effects that could have happened upon the global object.
Author names this object with the lowercase mathematical symbol for an empty set (ø) which can be entered in Windows by typing ALT+0248. It also stylistically conveys "I want this empty" better than just using 'null'.
The easiest way to set the object up as totally empty is by using Object.create(null), which is similar to { }, but without the delegation to Object.prototype, essentially making it "more empty" than { }.

-Indirection-
It is possible to create "indirect references" to functions, which then result in default binding rules being applied when that function is invoked.
One way an indirect reference might be made is with an assignment expression that assigns implicitly bound function to another implicitly bound function. This would result in value that is just a reference to the underlying function object, giving it a plain, undecorated call-site, which would utilize default binding rules.

-Softening Binding-
While hard binding prevents a function call from falling back to default binding (unless you use the 'new' operator), it reduces the flexibility of a function by preventing the use implicit or explicit overrides.
One way around this restriction is to construct a custom soft binding utility that allows you to set a different default instead of the usual global/undefined, while also allowing manual binding via the explicit and implicit binding techniques. You would wrap your specified function in logic that checks 'this' at call-time, check for global/undefined, and if found, replace it with a pre-defined default object. Otherwise, 'this' would be left untouched. You could also include the same currying functionality that is offered with bind(..).

-Lexical 'this'-
ES6 introduces a new special type of function that does not follow the previous 4 binding rules that were covered: The arrow function.
Arrow functions lexically adopt the binding of the enclosing (function or global) scope created at call-time and bind it to 'this'.
The lexical binding of an arrow-function can not be overridden, even by 'new'.
Arrow functions will most commonly be used in callbacks such as timers and event handlers.
A pre-ES6 pattern used to disable the traditional `this` mechanism in favor of lexical scoping was to create a variable reference to `this` in the enclosing function, and then using that variable in place of any `this` reference within your enclosed function.
Author opines that it's best not to mix lexical and `this` mechanisms in the same functions or even types of look-ups.

-Review-
Determining `this` binding:
1. Called with `new`? Use the newly constructed object.
2. Called with `call` or `apply`? Use the object specified.
3. Called with context object owning the call? Use the specified context object.
4. Default is `undefined` in strict mode, otherwise global object.
Beware of unintentionally invoking the default binding rule. To safely ignore a `this` binding, you can create a DMZ-like object (ø = Object.create(null)) as a placeholder value to protect global from unintended misuse.
ES6 arrow functions throw traditional `this` binding rules out the window in favor of lexical scoping rules, adopting `this` binding from the enclosing function call. They are a replacement of the `self = this` trick used in pre-ES6 coding.

===========================================Chapter 3===========================================
Objects

-Syntax-
Objects come in the declarative (literal) form and the constructed form. Both of these result in the same sort of object, with the only difference being that you can add multiple key/value pairs at once using the literal form, whereas you have to add properties individually when using the constructed form.
It's extremely uncommon to use the constructed form. You pretty much always want to use literal syntax. The same applies for built-in objects.

-Type-
Objects are one of 6 of the primary JS types (called "language types" in the specification), which also includes string, number, boolean, null, and undefined.
The simple primitives (the 5 other primary language types) are not themselves objects. `null` is sometimes referred to as an object type, but this is a misconception based on a bug in the language that causes `typeof null` to return a string "object" incorrectly. `null` is its own primitive type.
Everything in JavaScript is not an object.
There are a few special object sub-types, which will be referred to as "complex primitives". `function` is a sub-type that is technically a "callable object". Functions are said to be "first class" in JS, which means they are basically just normal, primary objects with the callable behavior semantics added on. They can be handled like any other regular object.
Arrays are also a form of object, with additional behaviors. The organization is slightly more structured than that of a regular object.

-Built-in Objects-
There are other object subtypes referred to as built-in objects. The relationship of the ones that share a name with their primitives is one of complexity and less-than-direct relation: String, Number, Boolean, Object, Function, Array, Date, RegExp, Error.
They have the appearance of being actual types or even classes if you compare them to other languages, but in JS, they are simply built-in functions. Each of them can be used as a constructor (a function call with a `new` operator), resulting in a newly-constructed object of the sub-type specified.
So basically, the built-in objects are object subtypes that construct the primitive or sub-type that their name refers to.
A string value such as "this is a string" is not an object but in fact a primitive literal and immutable value. To perform operations on it, such as checking its length, accessing individual characters, etc., you would do this via a String object.
The language automatically coerces a string primitive to a String object when necessary, meaning you almost never have to explicity create the built-in Object form. The majority strongly prefer to use the literal form for a value, allowing for implicit coercion over using the explicit constructed form. You can simply call a property or method on a string primitive and have it automatically coerce to a String object so that the property/method access works.
The same coercion occurs between the other literal primitives and their object wrappers.
`null` and `undefined` have no object wrappers, only primitive values.
`Date` values can only be created with their constructed object form, as they have no literal counterpart.
`Object`, `Array`, `Function`, and `RegExp` only exist as objects whether referred to in literal or constructed form. While the constructed form does offer more options in way of object creation, the simpler literal form is almost universally preferred. Only use the constructed form if you need these extra options.
`Error` objects are rarely created explicitly in code. They can be created with the constructed form `new Error(..)`, but this is not usually necessary.

-Contents-
The contents of objects are not necessarily stored inside the object itself, as the engine stores values in implementation-dependent ways in which they may not store them inside of an object container. The property names are stored in their respective objects, which act as pointers (or references, technically) to where the values are stored.
To access a location in an object, you need to either use the . operator (this syntax commonly referred to as property access) or the [ ] operator (commonly referred to as key access).
The `.` operator requires an Identifier-compatible property name after it, whereas the `[".."]` syntax can basically take any UTF-8/unicode-compatible string as the property name, so you would have to use the latter syntax if the property name had extraneous characters that were not acceptable as an Identifier property name.
Using any value other than a string in a property name will result in an attempt to implicitly coerce the value into a string primitive. This can be used to your advantage as you can feed a computed expression value as a key, but it can also cause problems if you for instance confuse using a number as an index (like you would with an array) instead of as a string value.

-Computed Property Names-
While you can easily use the myObj[..] property-access syntax to easily use a computed expression value as a key name, it doesn't provide any utility in the declaration of objects using object-literal syntax.
With ES6, you can now utilize computed property names, which allow you to specify an expression, using brackets [ ] to surround it, in place of the key name in an object-literal declaration.
The most common usage will likely be for the new ES6 Symbols, which are a new primitive data type likely described in the ES6 book.

-Property vs. Method-
In JS, functions never "belong" to objects, so a function that is accessed on an object reference isn't really automatically a method. It's easy to think otherwise, as in other languages, functions which belong to objects (classes), are referred to as methods.
Functions with `this` references referring to the object reference at the call-site are not any more a "method" than any other function, as `this` is dynamically bound at run-time, at the call-site. Its relationship to the object is fairly indirect.
Even if you access a property and receive a function in return, that still qualifies as "property access", rather than "method access", as they are only associated by reference.
Because of this, "function" and "method" are probably interchangeable in JavaScript.
ES6 adds the `super` reference which is typically going to be used with `class`. It uses static binding rather than using the traditional `this`, and gives nuance that a `super`-bound function is more method than function, but this is again a matter of debatable semantics.

-Arrays-
Arrays assume numeric indexing, which means values are stored in locations, called indices, at non-negative integers.
Arrays are objects, which means that even though each index is a positive integer, you can still add properties onto the array. Doing so will not change the reported length of the array.
You could add properties onto an array and never add any numeric indices, although you might as well use objects since arrays have special behaviors and optimizations specific to their purpose, just as plain objects do.
Be aware that when adding a property to an array with a name that resembles a number, the property value will instead end up being appended at the numeric index specified in the property name.

-Duplicating Objects-
When copying an object, you want to consider whether you want to create a shallow copy (just a new object, but any object references contained within still reference the same objects) or a deep copy (where the object and all object references contained are copied).
A problem that could come up is that one of the reference objects points to the main object that referred to it, create an infinite circular reference, causing endless duplication if being deep copied.
Various JS frameworks interpret this problem differently and implement their own solutions.
One solution is that ensure your object is JSON-safe (can be serialized to a JSON string and re-parsed to an object with the same structure and values), which is not always easy to do.
Because a shallow copy is easier to understand and less issue-prone, ES6 has introduced Object.assign(..). Object.assign(..) takes a target as its first parameter, and one or multiple sources for the following parameters. It iterates through all enumerable, owned keys (immediately present), and copies them via = assignment to target, and then returns that target.
Special characteristics on a property, like `writeable`, are not preserved using the shallow `=`-style assignment of Object.assign(..).

-Property Descriptors-
As of ES5, all properties are described in terms of a property descriptor. To get the property descriptor, you use Object.getOwnPropertyDescriptor( myObj, key );
A property descriptor that is only for holding a data value is called a data descriptor.
Other than the value, property descriptors also contain three other characteristics, `writable`, `enumerable`, and `configurable`.
You can use Object.defineProperty(..) to add a new property or modify existing ones (if `configurable`). You normally wouldn't manually add a property in this way unless you wanted to modify one of its descriptor characteristics differently than normal.

-Writable-
`writable` is the ability to change a property.
If you attempt to modify a non-writable property in strict mode, a TypeError will be thrown. In non-strict mode, the change will just silently fail.
`writable:false` is somewhat equivelent to if you defined a no-op setter, but would need to throw a TypeError when called to be conformant to `writeable:false`.

-Configurable-
If a property is not currently configurable, you will not be able to modify its descriptor definition using the Object.defineProperty(..) utility. Any attempt to do so will throw a TypeError, regardless of strict mode settings. The only exception is that writable can be changed from true to false without error (does not apply for changing it from false to true).
Setting a property to be non-configurable is a one-way action that cannot be undone.
`configurable:false` also prevents the ability to use the `delete` operator to remove the property. An attempt to delete in this situation will silently fail in non-strict mode and throw a TypeError in strict mode.
If an object property is the last remaining reference to an object, and you `delete` it, the now unreferenced object can be garbage collected. According to author, it is not proper to think of `delete` as a memory-freeing tool, as it is in other languages, but rather a simple object property removal operation.

-Enumerable-
This property characteristic determines whether a property will show up in particular object-property enumerations, such as `for..in` loops.
All user-defined properties are defaulted to `enumerable`.
